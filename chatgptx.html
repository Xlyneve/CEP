<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Minimal Chat with Full Features</title>
<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: 'Tahoma', sans-serif;
  color: #222;
  display: flex;
  flex-direction: column;
  overflow: hidden;

  /* Background image */
  background: url('2b.png') no-repeat center center fixed;
  background-size: cover;
  position: relative;
}

/* Glass overlay (must NOT block clicks) */
body::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  z-index: 0;
  pointer-events: none;
}

#chat {
  flex-grow: 1;
  width: 100%;
  padding: 20px 5vw 160px 80px;
  overflow-y: auto;
  font-size: 12px;
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  box-sizing: border-box;
  border-radius: 12px;
  position: relative;
  z-index: 1;
}

/* Live results area */
#liveResults {
  position: relative;
  z-index: 2;
}

/* Message bubbles */
.message {
  margin-left: 7px;
  margin-bottom: 8px;
  line-height: 1.6;
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
  word-break: break-word;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}

.message.user { align-items: flex-end; }

.message.bot {
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  padding-top: 12px;
  margin-top: 12px;
  margin-left: 7px;
}

.message img {
  max-width: 100%;
  margin-top: 6px;
  border-radius: 8px;
}

.editableNote a,
.chatBubble a {
  word-break: break-word;
  overflow-wrap: anywhere;
  color: #1a0dab;
  text-decoration: underline;
}

.chatBubble {
  background: rgba(255, 255, 255, 0.3);
  border-radius: 12px;
  padding: 8px 12px;
  max-width: 70%;
  animation: fadeIn 0.3s ease;
  word-wrap: break-word;
  white-space: pre-wrap;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  color: #222;
}

.message.user .chatBubble {
  background: rgba(224, 193, 198, 0.25);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  align-self: flex-end;
}

.message.bot .chatBubble {
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 0 12px 3px rgba(255, 255, 255, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  align-self: flex-start;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(6px); }
  to   { opacity: 1; transform: translateY(0); }
}

input[type="file"]::file-selector-button {
  background: rgba(255, 255, 255, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.4);
  border-radius: 8px;
  padding: 6px 12px;
  color: #333;
  cursor: pointer;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
  transition: box-shadow 0.3s ease;
}

input[type="file"]::file-selector-button:hover {
  background: rgba(255, 255, 255, 0.5);
  box-shadow: 0 0 20px 6px rgba(255, 255, 255, 0.7);
  color: #111;
}

/* Input Area */
#inputArea {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  width: 90vw;
  max-width: 600px;
  gap: 10px;
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  padding: 12px 20px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(100, 100, 100, 0.1);
  z-index: 100;
  box-sizing: border-box;
}

#inputArea, #notePanel {
  background: rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(255, 255, 255, 0.4);
}

#userInput {
  flex-grow: 1;
  font-size: 12px;
  padding: 10px 16px;
  border-radius: 12px;
  border: 1px solid #ddd;
  background: #f9f9f9;
  color: #3a3a3a;
  outline: none;
}

#userInput:focus {
  border-color: #999;
  box-shadow: 0 0 6px rgba(100, 100, 100, 0.4);
}

#sendBtn { display: none; }

/* Note Input */
#noteInput {
  min-height: 60px;
  max-height: 400px;
  overflow-y: auto;
  font-size: 13px;
  padding: 10px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.4);
  background: rgba(255, 255, 255, 0.15);
  color: #222;
  outline: none;
  white-space: pre-wrap;
  margin-top: 0 !important;
  padding-top: 0 !important;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.3);
}

#noteInput:empty:before {
  content: attr(data-placeholder);
  color: #aaa;
  pointer-events: none;
  display: block;
}

/* Editable Notes */
.editableNote {
  background: none;
  color: #222;
  padding: 4px;
  border: none;
  font-size: 12px;
  font-family: 'Tahoma', sans-serif;
  white-space: pre-wrap;
  outline: none;
}

.editableNote img {
  resize: both;
  overflow: auto;
  max-width: 100%;
  display: block;
  margin: 10px 0;
}

.resizableEmoji {
  font-size: 1.4em;
  font-weight: bold;
  display: inline-block;
}

/* Toolbar + Toggle */
#formatToggle {
  position: fixed;
  bottom: 40px;
  left: 20px;
  font-size: 20px;
  background: rgba(235, 235, 235, 0.25);
  border-radius: 50%;
  width: 44px;
  height: 44px;
  text-align: center;
  line-height: 44px;
  cursor: pointer;
  z-index: 105;
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.4);
  color: #444;
  transition: box-shadow 0.3s ease;
}

#formatToggle:hover {
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.75);
  color: #222;
}

#formatToolbar {
  position: fixed;
  bottom: 80px;
  left: 20px;
  display: none;
  flex-direction: column;
  flex-wrap: nowrap;
  gap: 8px;
  align-items: center;
  justify-content: flex-start;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 10px;
  padding: 5px 6px;
  z-index: 104;
  max-height: 500px;
  max-width: 90vw;
  overflow-x: auto;
  white-space: nowrap;
  -webkit-overflow-scrolling: touch;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  scrollbar-width: none;
  -ms-overflow-style: none;
  color: #444;
}

#formatToolbar.visible { display: flex; }

.format-btn {
  flex: 0 0 auto;
  background: none;
  border: none;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: #444;
  padding: 6px;
  border-radius: 6px;
  opacity: 0.7;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

.format-btn:hover {
  transform: scale(1.2);
  opacity: 1;
  color: #222;
}

.emoji {
  background: none;
  color: #444;
  border: none;
  cursor: pointer;
  opacity: 0.7;
  font-size: 16px;
  transition: all 0.2s ease;
}

.emoji:hover {
  transform: scale(1.2);
  opacity: 1;
}

/* Note Panel */
#noteContainer {
  position: fixed;
  bottom: 40px;
  right: 20px;
  width: 50px;
  height: 50px;
  z-index: 103;
}

#addNoteToggle {
  position: fixed;
  width: 50px;
  height: 50px;
  font-size: 28px;
  border-radius: 50%;
  background: rgba(208, 160, 163, 0.3);
  color: #333;
  border: 1px solid rgba(255, 255, 255, 0.4);
  cursor: pointer;
  box-shadow: 0 0 12px rgba(208, 160, 163, 0.5);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  transition: box-shadow 0.3s ease;
}

#addNoteToggle:hover {
  box-shadow: 0 0 20px rgba(208, 160, 163, 0.8);
  color: #222;
}

/* =========================
   Minimal Table Style (FIXED)
========================= */

.cellBox {
  display: block;
  width: 100%;
  min-height: 24px;
  padding: 6px 8px;
  box-sizing: border-box;

  outline: none;
  white-space: pre-wrap;
  word-break: break-word;

  overflow: hidden;      /* hide scrollbars normally */
  resize: none;          /* no resize handle by default */
  background: transparent;
  transition: background 0.15s ease;
}

/* Show resize ONLY when hovering */
.editable-table td:hover .cellBox,
.editable-table th:hover .cellBox {
  resize: both;
  overflow: auto;        /* enable scroll only when resizing */
}

.editable-table {
  border-collapse: collapse;
  border: 1px solid rgba(0,0,0,0.15);
}

.editable-table th,
.editable-table td {
  border: 1px solid rgba(0,0,0,0.10);
  padding: 0;
  background: transparent;
  vertical-align: top;   /* fixes middle vs left issue */
  text-align: left;
}

.editable-table th .cellBox {
  font-weight: 600;
}

.cellBox {
  display: block;
  width: 100%;
  min-height: 24px;
  padding: 6px 8px;
  box-sizing: border-box;
  outline: none;
  white-space: pre-wrap;
  word-break: break-word;
  overflow: hidden;
  resize: none;
  background: transparent;
}

/* Floating table controls */


#notePanel {
  position: absolute;
  bottom: 60px;
  right: 0;
  width: 300px;
  background: rgba(254, 254, 254, 0.25);
  color: #222;
  border-radius: 12px;
  padding: 16px;
  display: none;
  flex-direction: column;
  gap: 12px;
  box-shadow:
    0 0 6px 1px rgba(220, 230, 255, 0.2),
    0 0 25px 8px rgba(204, 153, 255, 0.2);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.5);
  z-index: 104;
  transition: none;
}

#addNoteBtn {
  background: rgba(236, 235, 232, 0.25);
  color: #3a3a3a;
  border: 1px solid rgba(255, 255, 255, 0.4);
  padding: 10px;
  border-radius: 8px;
  cursor: pointer;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 0 10px rgba(236, 235, 232, 0.4);
  transition: box-shadow 0.3s ease;
}

#addNoteBtn:hover {
  box-shadow: 0 0 16px rgba(236, 235, 232, 0.7);
  color: #222;
}

/* search highlight color */
.underlineMatch{
  background: rgba(208, 160, 163, 0.25); /* <-- change this */
  color: inherit;
  border-bottom: 1px dotted rgba(0,0,0,0.35);
  padding: 0 2px;
  border-radius: 4px;
}

/* if the browser still applies <mark> defaults */
mark.underlineMatch{
  background: rgba(208, 160, 163, 0.25);
}


/* Lock UI */
#lockToggle {
  position: fixed;
  top: 12px;
  right: 12px;
  background: #ecebe8;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 15px;
  text-align: center;
  line-height: 40px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  z-index: 200;
}

#lockSection {
  position: fixed;
  top: 60px;
  right: 12px;
  display: none;
  flex-direction: column;
  align-items: flex-end;
  background: rgba(255, 255, 255, 0.95);
  padding: 10px 12px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  gap: 8px;
  z-index: 199;
}

#lockSection input {
  background: #ecebe8;
  color: #333;
  border: 1px solid #ccc;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 10px;
}

#lockSection button {
  background: #d0a0a3;
  color: black;
  border: none;
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 10px;
}

#lockBtn:hover, #unlockBtn:hover { background: #ecebe8; }
#lockInfo { color: #555; font-weight: 100; }

/* Responsive */
@media (max-width: 600px) {
  #chat { padding: 12px 4vw 160px 4vw; }
  #inputArea { width: 70vw; bottom: 30px; }
  #notePanel { width: 90vw; right: 5vw; }
  #lockSection { top: 10px; right: 10px; gap: 6px; } /* fixed from #authSection */
}
</style>


</head>

<body>

<div id="lockToggle" title="Enter access code">üîí</div>

<div id="lockSection">
  <input type="password" id="accessCode" placeholder="Access code" autocomplete="off" />
  <button id="unlockBtn">Unlock</button>
  <button id="lockBtn" style="display:none;" title="Lock">üîí</button>
  <div id="lockInfo">Locked</div>
</div>


<div id="formatToggle">üìã</div>

<div id="formatToolbar">
  <button class="format-btn" id="boldBtn"><b>B</b></button>
  <button class="format-btn" id="italicBtn"><i>I</i></button>
  <button class="format-btn" id="underlineBtn"><u>U</u></button>
  <button class="format-btn" id="highlightBtn">üü™</button>
  <button class="format-btn" id="redFontBtn">üü•</button>
  <button class="format-btn" id="blueFontBtn">üü¶</button>

  <button class="format-btn" id="increaseFontBtn" title="Increase Font Size">üî∫A</button>
  <button class="format-btn" id="decreaseFontBtn" title="Decrease Font Size">üîªA</button>

  <button class="format-btn" id="insertTableBtn">üìä</button>
  <button class="format-btn" id="addRowBtn" title="Add Table Row">+R</button>
  <button class="format-btn" id="deleteRowBtn" title="Delete Table Row">-R</button>
  <button class="format-btn" id="addColBtn" title="Add Table Column">+C</button>
  <button class="format-btn" id="deleteColBtn" title="Delete Table Column">-C</button>

  <button class="format-btn" id="resetColorBtn">‚Ü∫</button>

  <div class="emoji" data-emoji="üìå">üìå</div>
  <div class="emoji" data-emoji="üü°">üü°</div>
  <div class="emoji" data-emoji="üî¥">üî¥</div>
  <div class="emoji" data-emoji="üî∏">üî∏</div>
  <div class="emoji" data-emoji="‚ñ∂">‚ñ∂</div>
  <div class="emoji" data-emoji="üëâüèª">üëâüèª</div>
  <div class="emoji" data-emoji="‚ö†Ô∏è">‚ö†Ô∏è</div>
  <div class="emoji" data-emoji="üß†">üß†</div>
  <div class="emoji" data-emoji="üíä">üíä</div>
  <div class="emoji" data-emoji="‚ù§Ô∏è">‚ù§Ô∏è</div>
  <div class="emoji" data-emoji="üö®">üö®</div>
  <div class="emoji" data-emoji="‚¨á">‚¨á</div>
  <div class="emoji" data-emoji="‚¨Ü">‚¨Ü</div>
  <div class="emoji" data-emoji="‚¨Ö">‚¨Ö</div>
  <div class="emoji" data-emoji="‚û°">‚û°</div>
  <div class="emoji" data-emoji="‚ûÄ">‚ûÄ</div>
  <div class="emoji" data-emoji="‚ûÅ">‚ûÅ</div>
  <div class="emoji" data-emoji="‚ûÇ">‚ûÇ</div>
  <div class="emoji" data-emoji="‚ûÉ">‚ûÉ</div>
</div>

<!-- Container for add button and note panel -->
<div id="noteContainer">
  <button id="addNoteToggle" title="Add Note">Ôºã</button>
  <div id="notePanel" style="display:none; flex-direction: column;">
    <div id="noteInput" contenteditable="true" data-placeholder="Type or paste your note here..."></div>
    <button id="addNoteBtn">Add Note</button>
  </div>
</div>

<!-- Chat area + Live Results go inside this -->
<div id="chat">
  <div id="liveResults"></div>
</div>

<form id="inputArea">
  <input type="text" id="userInput" placeholder="Type to search notes‚Ä¶ (use /ask to ask AI)" autocomplete="off" required />
  <button type="submit" id="sendBtn">Send</button>
</form>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>

<script type="module">
/* =========================
   Firebase init
========================= */
const firebaseConfig = {
  apiKey: "AIzaSyDtv3x9PAMzZUW6yVuUSLgLzA0ejcDidF4",
  authDomain: "notes-chat-c5ff3.firebaseapp.com",
  projectId: "notes-chat-c5ff3",
  storageBucket: "notes-chat-c5ff3.appspot.com",
  messagingSenderId: "597780727252",
  appId: "1:597780727252:web:8407eb4096dbe301d74241",
  measurementId: "G-YQD63H7L5T"
};

firebase.initializeApp(firebaseConfig);

const db = firebase.firestore();
const storage = firebase.storage();
const auth = firebase.auth();
auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);



/* =========================
   DOM refs
========================= */
const chat = document.getElementById('chat');
const liveResults = document.getElementById('liveResults');

const noteInput = document.getElementById('noteInput');
const addNoteBtn = document.getElementById('addNoteBtn');
const addNoteToggle = document.getElementById('addNoteToggle');
const notePanel = document.getElementById('notePanel');

const lockToggle = document.getElementById('lockToggle');
const lockSection = document.getElementById('lockSection');
const accessCodeInput = document.getElementById('accessCode');
const unlockBtn = document.getElementById('unlockBtn');
const lockBtn = document.getElementById('lockBtn');
const lockInfo = document.getElementById('lockInfo');

const inputArea = document.getElementById('inputArea');
const userInput = document.getElementById('userInput');


/* =========================
   Live search cache state
========================= */
let notesCache = [];
let unsubscribeNotes = null;
let liveTimer = null;
let lastLiveQuery = '';

function clearLiveResults() {
  liveResults.innerHTML = '';
}

function renderHeaderLine(text) {
  const header = document.createElement('div');
  header.className = 'message bot';
  const bubble = document.createElement('div');
  bubble.className = 'chatBubble';
  bubble.textContent = 'ü§ñ ' + text;
  header.appendChild(bubble);
  liveResults.appendChild(header);
}

function renderWelcome() {
  clearLiveResults();
  renderHeaderLine('‚úÖ Welcome. Type in the search box to find notes.');
}

function renderLiveResults(notes, queryLabel) {
  clearLiveResults();
  renderHeaderLine(`Results for: ${queryLabel}`);

  const container = document.createElement('div');
  liveResults.appendChild(container);

  displayNotesInto(container, notes);
  chat.scrollTo({ top: chat.scrollHeight, behavior: 'smooth' });
}

/* =========================
   Hard error banner (shows real JS errors)
========================= */
function showFatal(msg) {
  clearLiveResults();
  renderHeaderLine('‚ùå ' + msg);
}

window.addEventListener('error', (e) => {
  showFatal(e.message || 'Script error');
});

window.addEventListener('unhandledrejection', (e) => {
  showFatal((e.reason && (e.reason.message || String(e.reason))) || 'Unhandled promise rejection');
});

/* =========================
   Editor state
========================= */
let activeEditable = noteInput;
noteInput.addEventListener('focus', () => activeEditable = noteInput);

/* =========================
   Image upload inside notePanel (preview only)
========================= */
const imageUpload = document.createElement('input');
imageUpload.type = 'file';
imageUpload.accept = 'image/*';
imageUpload.id = 'imageUpload';
imageUpload.style.marginTop = '10px';
notePanel.insertBefore(imageUpload, addNoteBtn);

imageUpload.addEventListener('change', function () {
  const file = this.files?.[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    activeEditable.innerHTML += `<br><img src="${e.target.result}" style="max-width:100%; border-radius:8px;" /><br>`;
    placeCaretAtEnd(activeEditable);
    saveCaret();
  };
  reader.readAsDataURL(file);
});

// =========================
// Simple access code gate
// =========================
const ACCESS_CODE = "oatee"; // <-- change this to whatever you want
let isUnlocked = (localStorage.getItem('notes_unlocked') === '1');

function setUnlocked(state) {
  isUnlocked = state;
  localStorage.setItem('notes_unlocked', state ? '1' : '0');
  updateUIForLockState();
}



function updateUIForLockState() {
  if (isUnlocked) {
    lockInfo.textContent = "Unlocked";
    lockToggle.textContent = "üîì";
    lockToggle.title = "Unlocked";

    unlockBtn.style.display = "none";
    lockBtn.style.display = "inline-block";
    accessCodeInput.style.display = "none";

    addNoteToggle.style.display = 'inline-block';
    notePanel.style.display = 'none';

   startNotesListener();

  } else {
    lockInfo.textContent = "Locked";
    lockToggle.textContent = "üîí";
    lockToggle.title = "Enter access code";

    unlockBtn.style.display = "inline-block";
    lockBtn.style.display = "none";
    accessCodeInput.style.display = "inline-block";
    accessCodeInput.value = "";

    addNoteToggle.style.display = 'none';
    notePanel.style.display = 'none';

    stopNotesListener(); // stop + clear
  }
}

/* =========================
   Auth UI + realtime cache
========================= */
function startNotesListener() {
  if (!isUnlocked) return;
  if (unsubscribeNotes) unsubscribeNotes();

  unsubscribeNotes = db.collection('notes')
    .onSnapshot((snap) => {
      notesCache = snap.docs.map(d => ({ id: d.id, ...d.data() }));

      // newest first
      notesCache.sort((a, b) => {
        const ta = a.createdAt?.toMillis?.() || 0;
        const tb = b.createdAt?.toMillis?.() || 0;
        return tb - ta;
      });

      const q = userInput.value.trim();
if (q) {
  runLiveSearch(q, true);
} else {
  // don't show all notes on unlock/refresh
  renderWelcome();
}

    }, (err) => {
      console.error('Notes listener error:', err);
      showFatal('Firestore: ' + (err?.message || err));
    });
}

function stopNotesListener() {
  if (unsubscribeNotes) {
    unsubscribeNotes();
    unsubscribeNotes = null;
  }
  notesCache = [];
  clearLiveResults();
}

/* =========================
   Caret save/restore
========================= */
let savedRange = null;

function saveCaret() {
  const sel = window.getSelection();
  if (sel.rangeCount > 0 && activeEditable.contains(sel.anchorNode)) {
    savedRange = sel.getRangeAt(0).cloneRange();
  }
}

function restoreCaret() {
  if (!savedRange) return false;
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(savedRange);
  return true;
}

function placeCaretAtEnd(el) {
  el.focus();
  const range = document.createRange();
  range.selectNodeContents(el);
  range.collapse(false);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
  savedRange = range.cloneRange();
}

['keyup', 'mouseup', 'focus', 'input'].forEach(evt => {
  noteInput.addEventListener(evt, saveCaret);
});

/* =========================
   Emoji insert
========================= */
document.querySelectorAll('.emoji').forEach(btn => {
  btn.onclick = async () => {
    const emoji = btn.dataset.emoji;
    activeEditable.focus();

    const resizable = ["‚¨á", "‚¨Ü", "‚¨Ö", "‚û°", "‚ûÄ", "‚ûÅ", "‚ûÇ", "‚ûÉ"].includes(emoji);

    if (!restoreCaret()) {
      activeEditable.innerHTML += resizable
        ? `<span class="resizableEmoji">${emoji}</span>`
        : emoji;
      placeCaretAtEnd(activeEditable);
    } else {
      const sel = window.getSelection();
      const range = sel.getRangeAt(0);
      range.deleteContents();

      if (resizable) {
        const span = document.createElement('span');
        span.className = 'resizableEmoji';
        span.textContent = emoji;
        range.insertNode(span);
        range.setStartAfter(span);
      } else {
        const textNode = document.createTextNode(emoji);
        range.insertNode(textNode);
        range.setStartAfter(textNode);
      }

      range.collapse(true);
      sel.removeAllRanges();
      sel.addRange(range);
    }

    saveCaret();

    try { await navigator.clipboard.writeText(emoji); } catch {}

    btn.style.transform = 'scale(1.3)';
    setTimeout(() => (btn.style.transform = 'scale(1)'), 200);
  };
});

/* =========================
   Notes panel toggle
========================= */
addNoteToggle.onclick = () => {
  notePanel.style.display = (notePanel.style.display === 'flex') ? 'none' : 'flex';
  activeEditable = noteInput;
  noteInput.focus();
};

/* =========================
   Linkify
========================= */
function linkify(html) {
  const div = document.createElement('div');
  div.innerHTML = html;

  const walker = document.createTreeWalker(div, NodeFilter.SHOW_TEXT, null);
  const urlRegex = /\bhttps?:\/\/[^\s<]+/gi;

  const textNodes = [];
  while (walker.nextNode()) textNodes.push(walker.currentNode);

  textNodes.forEach(node => {
    const text = node.nodeValue;
    if (!urlRegex.test(text)) return;

    const frag = document.createDocumentFragment();
    let lastIndex = 0;
    text.replace(urlRegex, (match, offset) => {
      frag.appendChild(document.createTextNode(text.slice(lastIndex, offset)));
      const a = document.createElement('a');
      a.href = match;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      a.textContent = match;
      frag.appendChild(a);
      lastIndex = offset + match.length;
      return match;
    });
    frag.appendChild(document.createTextNode(text.slice(lastIndex)));

    node.parentNode.replaceChild(frag, node);
  });

  return div.innerHTML;
}

/* =========================
   Add note
========================= */
addNoteBtn.onclick = async () => {
  if (!isUnlocked) return alert('Locked.');

  const raw = noteInput.innerHTML.trim();
  const noteContent = linkify(raw);

  if (!noteContent || noteContent === '<br>') return alert('Note is required.');

  addNoteBtn.disabled = true;
  addNoteBtn.textContent = 'Adding...';

  try {
    await ensureSignedIn();
    await db.collection('notes').add({
      content: noteContent,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
      // uid removed
    });

    noteInput.innerHTML = '';
    imageUpload.value = '';
    notePanel.style.display = 'none';

    const q = userInput.value.trim();
    if (q) runLiveSearch(q, true);
    else renderLiveResults(notesCache.slice(0, 30), 'Latest notes');

  } catch (e) {
    alert('Error: ' + e.message);
  } finally {
    addNoteBtn.disabled = false;
    addNoteBtn.textContent = 'Add Note';
  }
};

async function ensureSignedIn() {
  // If already signed in, done
  if (auth.currentUser) return auth.currentUser;

  // Wait for auth to finish initializing
  await new Promise((resolve) => {
    const unsub = auth.onAuthStateChanged(() => {
      unsub();
      resolve();
    });
  });

  if (auth.currentUser) return auth.currentUser;

  // Try anonymous sign-in
  try {
    await auth.signInAnonymously();
    console.log("Signed in uid:", auth.currentUser?.uid);
    return auth.currentUser;
  } catch (e) {
    console.error("Anonymous sign-in failed:", e);
    throw e;
  }
}


function stripLegacyTableControls(html) {
  if (!html) return '';
  return html
    .replace(/<button[^>]*class="table-control-toggle"[\s\S]*?<\/button>/gi, '')
    .replace(/<div[^>]*class="table-control-panel"[\s\S]*?<\/div>/gi, '')
    .replace(/<button[^>]*class="table-btn"[\s\S]*?<\/button>/gi, '');
}

/* =========================
   "AI" placeholder (only used if you type /ask ...)
========================= */
async function askAI(question) {
  await new Promise(res => setTimeout(res, 250));
  return `You asked:\n${question}`;
}

/* =========================
   Search helpers
========================= */
function normalizeText(s) {
  return (s || '')
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .trim();
}

function htmlToText(html) {
  const div = document.createElement('div');
  div.innerHTML = html || '';
  return div.textContent || div.innerText || '';
}

function parseFindQuery(raw) {
  const s = raw.replace(/^\/find\s+/i, '').trim();

  const phrases = [];
  const quoteRegex = /"([^"]+)"/g;
  let m;
  while ((m = quoteRegex.exec(s)) !== null) {
    const p = m[1].trim();
    if (p) phrases.push(p);
  }

  const remainder = s.replace(quoteRegex, ' ').split(',')
    .map(t => t.trim())
    .filter(Boolean);

  const terms = [...phrases, ...remainder].filter(Boolean);

  return { raw: s, terms: terms.map(normalizeText).filter(Boolean) };
}

function scoreDoc(textNorm, termsNorm) {
  let score = 0;
  for (const t of termsNorm) {
    if (!t) continue;
    if (textNorm.startsWith(t)) score += 6;

    const wholeWord = new RegExp(`\\b${t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
    if (wholeWord.test(textNorm)) score += 3;

    if (textNorm.includes(t)) score += 1;
  }
  return score;
}

function highlightHTML(html, termsNorm) {
  if (!termsNorm?.length) return html;

  const container = document.createElement('div');
  container.innerHTML = html;

  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
  const nodes = [];
  while (walker.nextNode()) nodes.push(walker.currentNode);

  const escaped = termsNorm
    .filter(Boolean)
    .sort((a, b) => b.length - a.length)
    .map(t => t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));

  if (!escaped.length) return html;
  const regex = new RegExp(`(${escaped.join('|')})`, 'gi');

  nodes.forEach(node => {
    const text = node.nodeValue;
    if (!regex.test(text)) return;

    const span = document.createElement('span');
    span.innerHTML = text.replace(regex, `<mark class="underlineMatch">$1</mark>`);
    node.parentNode.replaceChild(span, node);
  });

  return container.innerHTML;
}

/* =========================
   Cache-based query (SYNC + stable)
========================= */
function queryNotesSync(rawQuery) {
  if (!isUnlocked) return [];

  const { terms } = parseFindQuery(rawQuery);
  if (!terms.length) return notesCache.slice(0, 30);

  const results = [];

  for (const data of notesCache) {
    const originalHtml = data.content || '';
    const cleanedHtml = stripLegacyTableControls(originalHtml);

    const textNorm = normalizeText(htmlToText(cleanedHtml));

    const ok = terms.every(t => {
      if (!t) return true;
      if (textNorm.includes(t)) return true;
      return textNorm.split(/\s+/).some(w => w.startsWith(t));
    });

    if (!ok) continue;

    results.push({
      id: data.id,
      createdAt: data.createdAt,
      content: highlightHTML(cleanedHtml, terms),
      score: scoreDoc(textNorm, terms)
    });
  }

  results.sort((a, b) => {
    const s = b.score - a.score;
    if (s !== 0) return s;
    const ta = a.createdAt?.toMillis?.() || 0;
    const tb = b.createdAt?.toMillis?.() || 0;
    return tb - ta;
  });

  return results.slice(0, 30);
}

/* =========================
   Render notes into ANY container
========================= */
function displayNotesInto(targetEl, notes) {
  if (!notes.length) {
    const msg = document.createElement('div');
    msg.className = 'message bot';
    const bubble = document.createElement('div');
    bubble.className = 'chatBubble';
    bubble.textContent = 'ü§ñ ‚ùå No matching notes found.';
    msg.appendChild(bubble);
    targetEl.appendChild(msg);
    return;
  }

  for (const note of notes) {
    const div = document.createElement('div');
    div.className = 'message bot';

    const bubble = document.createElement('div');
    bubble.className = 'chatBubble';
    bubble.innerHTML = 'ü§ñ ' + stripLegacyTableControls(note.content || '');
    div.appendChild(bubble);

    const btns = document.createElement('div');
    btns.style.textAlign = 'center';
    btns.style.marginTop = '6px';

    const editBtn = document.createElement('button');
    editBtn.textContent = '‚úèÔ∏è';
    const delBtn = document.createElement('button');
    delBtn.textContent = 'üóëÔ∏è';

    [editBtn, delBtn].forEach(btn => Object.assign(btn.style, {
      background: 'none',
      border: 'none',
      color: '#666',
      fontSize: '16px',
      cursor: 'pointer',
      marginRight: '12px'
    }));

    btns.append(editBtn, delBtn);
    div.appendChild(btns);
    targetEl.appendChild(div);

    editBtn.onclick = () => {
      bubble.style.display = 'none';
      btns.style.display = 'none';

      const editable = document.createElement('div');
      editable.contentEditable = true;
      editable.innerHTML = (note.content || '').replace(/<mark class="underlineMatch">([\s\S]*?)<\/mark>/gi, '$1');
      editable.className = 'editableNote';
      activeEditable = editable;

      editable.addEventListener('focus', () => activeEditable = editable);
      editable.addEventListener('input', saveCaret);
      editable.addEventListener('mouseup', saveCaret);
      editable.addEventListener('keyup', saveCaret);

      const saveBtn = document.createElement('button');
      const cancelBtn = document.createElement('button');
      saveBtn.textContent = 'üíæ';
      cancelBtn.textContent = '‚ùå';

      [saveBtn, cancelBtn].forEach(btn => Object.assign(btn.style, {
        background: 'none',
        border: 'none',
        color: '#666',
        fontSize: '16px',
        cursor: 'pointer',
        marginRight: '12px'
      }));

      const actions = document.createElement('div');
      actions.style.textAlign = 'center';
      actions.style.marginTop = '6px';
      actions.append(saveBtn, cancelBtn);

      div.append(editable, actions);

      cancelBtn.onclick = () => {
        editable.remove();
        actions.remove();
        bubble.style.display = '';
        btns.style.display = '';
      };

      saveBtn.onclick = async () => {
        const updated = editable.innerHTML.trim();
        if (!updated) return alert('Cannot save empty note');

        try {
		  await ensureSignedIn();
          await db.collection('notes').doc(note.id).update({ content: updated });
          note.content = updated;

          bubble.innerHTML = 'ü§ñ ' + updated;
          editable.remove();
          actions.remove();
          bubble.style.display = '';
          btns.style.display = '';

          const q = userInput.value.trim();
          if (q) runLiveSearch(q, true);
          else renderLiveResults(notesCache.slice(0, 30), 'Latest notes');

        } catch (e) {
          alert('Error saving note: ' + e.message);
        }
      };
    };

    delBtn.onclick = async () => {
      if (!confirm('Delete this note?')) return;
      try {
	     await ensureSignedIn();
        await db.collection('notes').doc(note.id).delete();
        div.remove();

        const q = userInput.value.trim();
        if (q) runLiveSearch(q, true);
        else renderLiveResults(notesCache.slice(0, 30), 'Latest notes');

      } catch (e) {
        alert('Failed to delete: ' + e.message);
      }
    };
  }
}

/* =========================
   Live search runner (SYNC + stable)
========================= */
function runLiveSearch(q, immediate = false) {
  if (!isUnlocked) return;

  const doIt = () => {
    lastLiveQuery = q;

    try {
      const notes = queryNotesSync('/find ' + q);
      renderLiveResults(notes, q);
    } catch (e) {
      console.error(e);
      showFatal('Search/render error: ' + (e?.message || e));
    }
  };

  if (immediate) return doIt();

  clearTimeout(liveTimer);
  liveTimer = setTimeout(doIt, 120);
}

/* =========================
   LIVE SEARCH as you type
========================= */
userInput.addEventListener('input', () => {
  const q = userInput.value.trim();

  if (!q) {
  lastLiveQuery = '';
  if (isUnlocked) renderWelcome();
  else clearLiveResults();
  return;
}


  runLiveSearch(q, false);
});

/* =========================
   Enter key behavior
   - default: searches notes (no chat spam)
   - use /ask ... to call askAI()
========================= */
inputArea.addEventListener('submit', async (e) => {
  e.preventDefault();

  const raw = userInput.value.trim();
  if (!raw) return;

  if (/^\/ask\b/i.test(raw)) {
    const q = raw.replace(/^\/ask\s*/i, '').trim();
    if (!q) return;

    clearLiveResults();
    renderHeaderLine('Thinking‚Ä¶');

    try {
      const answer = await askAI(q);
      clearLiveResults();
      renderHeaderLine(answer);
    } catch (err) {
      clearLiveResults();
      renderHeaderLine('‚ö†Ô∏è Error getting response');
      console.error(err);
    }
    return;
  }

  runLiveSearch(raw, true);
});

/* =========================
   Formatting toolbar
========================= */
document.getElementById('boldBtn').onclick = () => document.execCommand('bold');
document.getElementById('italicBtn').onclick = () => document.execCommand('italic');
document.getElementById('underlineBtn').onclick = () => document.execCommand('underline');
document.getElementById('highlightBtn').onclick = () => document.execCommand('foreColor', false, '#5c6ac4');
document.getElementById('redFontBtn').onclick = () => document.execCommand('foreColor', false, 'red');
document.getElementById('blueFontBtn').onclick = () => document.execCommand('foreColor', false, 'blue');

/* Font size controls */
function changeFontSize(delta) {
  const sel = window.getSelection();
  if (!sel.rangeCount || !activeEditable.contains(sel.anchorNode)) return;

  const range = sel.getRangeAt(0);

  if (!range.collapsed) {
    const selectedNodes = range.cloneContents().querySelectorAll('span.resizableEmoji');

    if (selectedNodes.length) {
      selectedNodes.forEach(span => {
        const currentSize = parseFloat(window.getComputedStyle(span).fontSize);
        const newSize = Math.max(8, currentSize + delta * 2);
        span.style.fontSize = newSize + 'px';
      });
      return;
    }

    const span = document.createElement('span');
    span.style.fontSize = delta > 0 ? 'larger' : 'smaller';
    span.appendChild(range.extractContents());
    range.insertNode(span);
  } else {
    const span = document.createElement('span');
    span.style.fontSize = delta > 0 ? 'larger' : 'smaller';
    span.appendChild(document.createTextNode('\u200B'));
    range.insertNode(span);
    range.setStart(span, 1);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  saveCaret();
}

function resetFormatting() {
  const sel = window.getSelection();
  if (!sel.rangeCount || !activeEditable.contains(sel.anchorNode)) return;

  const range = sel.getRangeAt(0);
  if (range.collapsed) return;

  const extracted = range.extractContents();

  function unwrapNode(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      return document.createTextNode(node.textContent);
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const frag = document.createDocumentFragment();
      node.childNodes.forEach(child => frag.appendChild(unwrapNode(child)));
      return frag;
    }
    return document.createTextNode('');
  }

  const cleanFragment = document.createDocumentFragment();
  extracted.childNodes.forEach(node => cleanFragment.appendChild(unwrapNode(node)));

  range.insertNode(cleanFragment);
  range.collapse(false);
  sel.removeAllRanges();
  sel.addRange(range);

  saveCaret();
}

document.getElementById('resetColorBtn').onclick = resetFormatting;
document.getElementById('increaseFontBtn').onclick = () => changeFontSize(1);
document.getElementById('decreaseFontBtn').onclick = () => changeFontSize(-1);

/* =========================
   Table tools (UPGRADED)
========================= */
function getCurrentCell() {
  const sel = window.getSelection();
  if (!sel.rangeCount) return null;
  const node = sel.anchorNode;
  if (!node) return null;

  const el = (node.nodeType === 1) ? node : node.parentElement;
  if (!el) return null;

  return el.closest('td, th');
}

function getTableFromCell(cell) {
  return cell ? cell.closest('table') : null;
}

function ensureColgroup(table) {
  if (!table) return null;
  let colgroup = table.querySelector('colgroup');
  const colCount = table.tHead?.rows?.[0]?.cells?.length || table.rows?.[0]?.cells?.length || 0;

  if (!colgroup) {
    colgroup = document.createElement('colgroup');
    for (let i = 0; i < colCount; i++) {
      const col = document.createElement('col');
      col.style.width = `${Math.floor(100 / Math.max(colCount, 1))}%`;
      colgroup.appendChild(col);
    }
    table.insertBefore(colgroup, table.firstChild);
  } else {
    const existing = colgroup.querySelectorAll('col').length;
    if (existing < colCount) {
      for (let i = existing; i < colCount; i++) {
        const col = document.createElement('col');
        col.style.width = `${Math.floor(100 / Math.max(colCount, 1))}%`;
        colgroup.appendChild(col);
      }
    }
  }
  return colgroup;
}

function normalizeColWidths(table) {
  const colgroup = table.querySelector('colgroup');
  if (!colgroup) return;

  const cols = Array.from(colgroup.querySelectorAll('col'));
  const n = cols.length;
  if (!n) return;

  const anyPx = cols.some(c => (c.style.width || '').includes('px'));
  if (!anyPx) {
    const pct = `${Math.floor(100 / n)}%`;
    cols.forEach(c => (c.style.width = pct));
  }
}

function ensureCellBoxes(table) {
  if (!table) return;

  const cells = table.querySelectorAll('th, td');

  cells.forEach(cell => {
    const existing = cell.querySelector(':scope > .cellBox');
    if (existing) {
      cell.contentEditable = 'false';
      existing.contentEditable = 'true';
      return;
    }

    const box = document.createElement('div');
    box.className = 'cellBox';
    box.contentEditable = 'true';
    box.innerHTML = cell.innerHTML || '';

    cell.innerHTML = '';
    cell.appendChild(box);
    cell.contentEditable = 'false';
  });
}

function persistCellSizeFromBox(box) {
  const cell = box.closest('td, th');
  if (!cell) return;

  const w = box.style.width;
  const h = box.style.height;

  if (w) cell.style.width = w;
  if (h) cell.style.height = h;
}

document.getElementById('insertTableBtn').onclick = () => {
  const html = `
  <table class="editable-table" contenteditable="false">
    <colgroup>
      <col style="width:50%">
      <col style="width:50%">
    </colgroup>
    <thead>
      <tr>
        <th><div class="cellBox" contenteditable="true"></div></th>
        <th><div class="cellBox" contenteditable="true"></div></th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td><div class="cellBox" contenteditable="true"></div></td>
        <td><div class="cellBox" contenteditable="true"></div></td>
      </tr>
    </tbody>
  </table><br>`;

  activeEditable.focus();

  if (!restoreCaret()) {
    activeEditable.innerHTML += html;
    placeCaretAtEnd(activeEditable);
  } else {
    const sel = window.getSelection();
    const range = sel.getRangeAt(0);
    range.deleteContents();

    const temp = document.createElement('div');
    temp.innerHTML = html;

    const frag = document.createDocumentFragment();
    while (temp.firstChild) frag.appendChild(temp.firstChild);

    range.insertNode(frag);
    range.collapse(false);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  saveCaret();

  setTimeout(() => {
    const cell = getCurrentCell();
    const table = getTableFromCell(cell) || activeEditable.querySelector('table.editable-table:last-of-type');
    if (table) {
      ensureCellBoxes(table);
      ensureColgroup(table);
      normalizeColWidths(table);
    }
  }, 0);
};

function addTableRowAtCursor() {
  const cell = getCurrentCell();
  const table = getTableFromCell(cell);
  if (!table) return alert('Place the cursor inside a table.');

  ensureCellBoxes(table);
  const tbody = table.tBodies[0] || table.createTBody();

  const colCount =
    table.tHead?.rows?.[0]?.cells?.length ||
    tbody.rows?.[0]?.cells?.length ||
    1;

  let insertIndex = tbody.rows.length;
  const row = cell?.parentElement;
  if (row && row.parentElement === tbody) {
    insertIndex = row.rowIndex;
    const headRows = table.tHead ? table.tHead.rows.length : 0;
    const tbodyIndex = insertIndex - headRows;
    insertIndex = Math.min(tbodyIndex + 1, tbody.rows.length);
  }

  const newRow = tbody.insertRow(insertIndex);
  for (let i = 0; i < colCount; i++) {
    const c = newRow.insertCell();
    c.contentEditable = 'false';
    c.innerHTML = `<div class="cellBox" contenteditable="true"></div>`;
  }
}

function deleteTableRowAtCursor() {
  const cell = getCurrentCell();
  const table = getTableFromCell(cell);
  if (!table) return alert('Place the cursor inside a table.');

  const tbody = table.tBodies[0];
  if (!tbody) return alert('No table body found.');
  if (tbody.rows.length <= 1) return alert('Cannot delete the last row.');

  const row = cell?.parentElement;
  if (!row || row.parentElement !== tbody) return alert('Click inside a body row to delete it.');
  row.remove();
}

function addTableColumnAtCursor() {
  const cell = getCurrentCell();
  const table = getTableFromCell(cell);
  if (!table) return alert('Place the cursor inside a table.');

  ensureCellBoxes(table);
  const colgroup = ensureColgroup(table);

  const idx = cell ? cell.cellIndex : (table.tHead?.rows?.[0]?.cells?.length || 0) - 1;
  const insertAt = Math.max(0, idx + 1);

  if (table.tHead && table.tHead.rows[0]) {
    const th = table.tHead.rows[0].insertCell(insertAt);
    th.outerHTML = `<th><div class="cellBox" contenteditable="true"></div></th>`;
  }

  const tbody = table.tBodies[0] || table.createTBody();
  Array.from(tbody.rows).forEach(row => {
    const td = row.insertCell(insertAt);
    td.contentEditable = 'false';
    td.innerHTML = `<div class="cellBox" contenteditable="true"></div>`;
  });

  if (colgroup) {
    const cols = Array.from(colgroup.querySelectorAll('col'));
    const newCol = document.createElement('col');
    const ref = cols[Math.min(insertAt, cols.length - 1)];
    newCol.style.width = ref?.style?.width || `${Math.floor(100 / (cols.length + 1))}%`;

    if (insertAt >= cols.length) colgroup.appendChild(newCol);
    else colgroup.insertBefore(newCol, cols[insertAt]);

    normalizeColWidths(table);
  }
}

function deleteTableColumnAtCursor() {
  const cell = getCurrentCell();
  const table = getTableFromCell(cell);
  if (!table) return alert('Place the cursor inside a table.');

  const idx = cell ? cell.cellIndex : null;
  if (idx === null) return alert('Click inside a column to delete it.');

  const headCells = table.tHead?.rows?.[0]?.cells?.length || 0;
  const bodyCells = table.tBodies[0]?.rows?.[0]?.cells?.length || 0;
  const colCount = Math.max(headCells, bodyCells);

  if (colCount <= 1) return alert('Cannot delete the last column.');

  if (table.tHead && table.tHead.rows[0] && table.tHead.rows[0].cells[idx]) {
    table.tHead.rows[0].deleteCell(idx);
  }

  const tbody = table.tBodies[0];
  if (tbody) {
    Array.from(tbody.rows).forEach(row => {
      if (row.cells[idx]) row.deleteCell(idx);
    });
  }

  const colgroup = table.querySelector('colgroup');
  if (colgroup) {
    const cols = colgroup.querySelectorAll('col');
    if (cols[idx]) cols[idx].remove();
    normalizeColWidths(table);
  }
}

document.getElementById('addRowBtn').onclick = addTableRowAtCursor;
document.getElementById('deleteRowBtn').onclick = deleteTableRowAtCursor;
document.getElementById('addColBtn').onclick = addTableColumnAtCursor;
document.getElementById('deleteColBtn').onclick = deleteTableColumnAtCursor;

document.addEventListener('click', (e) => {
  const table = e.target.closest('table.editable-table');
  if (!table) return;
  ensureCellBoxes(table);
  ensureColgroup(table);
  normalizeColWidths(table);
});

document.addEventListener('mouseup', (e) => {
  const box = e.target.closest?.('.cellBox');
  if (!box) return;
  persistCellSizeFromBox(box);
});


/* Table cells: Shift+Enter = newline INSIDE cellBox, Enter = blocked */
document.addEventListener('keydown', (e) => {
  if (e.key !== 'Enter') return;

  // Find the .cellBox from the current selection (more reliable than e.target)
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return;

  const range = sel.getRangeAt(0);

  const anchorEl =
    (sel.anchorNode?.nodeType === 1 ? sel.anchorNode : sel.anchorNode?.parentElement) ||
    (range.commonAncestorContainer?.nodeType === 1 ? range.commonAncestorContainer : range.commonAncestorContainer?.parentElement);

  const box = anchorEl?.closest?.('.cellBox');
  if (!box) return; // not inside a table cellBox

  // Always stop the browser from doing table/contenteditable weirdness
  e.preventDefault();
  e.stopPropagation();

  // Only Shift+Enter inserts a newline
  if (!e.shiftKey) return;

  // Insert a real line break and place caret after it
  const br = document.createElement('br');
  range.deleteContents();
  range.insertNode(br);

  // Move caret after the <br>
  range.setStartAfter(br);
  range.collapse(true);
  sel.removeAllRanges();
  sel.addRange(range);
}, true); // <-- capture mode so it runs before other handlers
/* UI toggles */
lockToggle.onclick = () => {
  lockSection.style.display = (lockSection.style.display === 'flex') ? 'none' : 'flex';
};

unlockBtn.onclick = () => {
  const code = (accessCodeInput.value || '').trim();
  if (code === ACCESS_CODE) {
    setUnlocked(true);
    lockSection.style.display = 'none';
  } else {
    lockInfo.textContent = "Wrong code";
    accessCodeInput.select();
  }
};

lockBtn.onclick = () => {
  setUnlocked(false);
  lockSection.style.display = 'none';
};

document.getElementById('formatToggle').onclick = () =>
  document.getElementById('formatToolbar').classList.toggle('visible');

/* Double-click resize popup for images inside editable note editor */
document.addEventListener('dblclick', (e) => {
  if (e.target.tagName === 'IMG' && e.target.closest('.editableNote')) {
    const img = e.target;

    const popup = document.createElement('div');
    popup.style.position = 'fixed';
    popup.style.left = `${e.clientX}px`;
    popup.style.top = `${e.clientY}px`;
    popup.style.background = '#fff';
    popup.style.border = '1px solid #ccc';
    popup.style.padding = '10px';
    popup.style.zIndex = '10000';
    popup.style.boxShadow = '0 2px 8px rgba(0,0,0,0.2)';
    popup.style.borderRadius = '6px';

    const widthInput = document.createElement('input');
    widthInput.type = 'number';
    widthInput.placeholder = 'Width (px)';
    widthInput.value = img.width;
    widthInput.style.marginRight = '8px';

    const heightInput = document.createElement('input');
    heightInput.type = 'number';
    heightInput.placeholder = 'Height (px)';
    heightInput.value = img.height;

    const applyBtn = document.createElement('button');
    applyBtn.textContent = '‚úîÔ∏è';
    applyBtn.style.marginLeft = '8px';

    applyBtn.onclick = () => {
      img.style.width = widthInput.value + 'px';
      img.style.height = heightInput.value + 'px';
      popup.remove();
    };

    document.addEventListener('click', function outsideClick(ev) {
      if (!popup.contains(ev.target) && ev.target !== img) {
        popup.remove();
        document.removeEventListener('click', outsideClick);
      }
    });

    popup.append(widthInput, heightInput, applyBtn);
    document.body.appendChild(popup);
  }
});

updateUIForLockState();

</script>

</body>
</html>
