<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Minimal Chat with Full Features</title>
<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: 'Tahoma', sans-serif;
  color: #222;
  display: flex;
  flex-direction: column;
  overflow: hidden;

  /* Background image */
  background: url('2b.png') no-repeat center center fixed;
  background-size: cover;
  position: relative;
}

/* Glass overlay (must NOT block clicks) */
body::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  z-index: 0;
  pointer-events: none;
}

#chat {
  flex-grow: 1;
  width: 100%;
  padding: 20px 5vw 160px 80px;
  overflow-y: auto;
  font-size: 12px;
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  box-sizing: border-box;
  border-radius: 12px;
  position: relative;
  z-index: 1;
}

/* Live results area */
#liveResults {
  position: relative;
  z-index: 2;
}

/* Message bubbles */
.message {
  margin-left: 7px;
  margin-bottom: 8px;
  line-height: 1.6;
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
  word-break: break-word;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}

.message.user { align-items: flex-end; }

.message.bot {
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  padding-top: 12px;
  margin-top: 12px;
  margin-left: 7px;
}

.message img {
  max-width: 100%;
  margin-top: 6px;
  border-radius: 8px;
}

.editableNote a:not(.conceptLink),
.chatBubble a:not(.conceptLink) {
  color: #1a0dab;
  text-decoration: underline;
}

.chatBubble {
  background: rgba(255, 255, 255, 0.88);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  border-radius: 16px;
  padding: 10px 16px;
  max-width: 88%;

  border: 1px solid rgba(0, 0, 0, 0.05);
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.05);

  color: #1f1f1f;
}

.chatBubble { position: relative; overflow: visible; }
.message { overflow: visible; }

.message.user .chatBubble {
  background: rgba(248, 244, 246, 0.75);
}

.message.bot .chatBubble {
  background: rgba(255, 255, 255, 0.75);
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(6px); }
  to   { opacity: 1; transform: translateY(0); }
}

input[type="file"]::file-selector-button {
  background: rgba(255, 255, 255, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.4);
  border-radius: 8px;
  padding: 6px 12px;
  color: #333;
  cursor: pointer;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
  transition: box-shadow 0.3s ease;
}

input[type="file"]::file-selector-button:hover {
  background: rgba(255, 255, 255, 0.5);
  box-shadow: 0 0 20px 6px rgba(255, 255, 255, 0.7);
  color: #111;
}

/* Input Area */
#inputArea {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  width: 90vw;
  max-width: 600px;
  gap: 10px;
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  padding: 12px 20px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(100, 100, 100, 0.1);
  z-index: 100;
  box-sizing: border-box;
}

#inputArea, #notePanel {
  background: rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(255, 255, 255, 0.4);
}

#userInput {
  flex-grow: 1;
  font-size: 12px;
  padding: 10px 16px;
  border-radius: 12px;
  border: 1px solid #ddd;
  background: #f9f9f9;
  color: #3a3a3a;
  outline: none;
}

#userInput:focus {
  border-color: #999;
  box-shadow: 0 0 6px rgba(100, 100, 100, 0.4);
}

#sendBtn { display: none; }

/* Note Input */
#noteInput {
  min-height: 60px;
  max-height: 400px;
  overflow-y: auto;
  font-size: 13px;
  padding: 10px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.4);
  background: rgba(255, 255, 255, 0.15);
  color: #222;
  outline: none;
  white-space: pre-wrap;
  margin-top: 0 !important;
  padding-top: 0 !important;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.3);
}

#noteInput:empty:before {
  content: attr(data-placeholder);
  color: #aaa;
  pointer-events: none;
  display: block;
}

/* Editable Notes */
.editableNote {
  background: none;
  color: #222;
  padding: 4px;
  border: none;
  font-size: 12px;
  font-family: 'Tahoma', sans-serif;
  white-space: pre-wrap;
  outline: none;
}



.resizableEmoji {
  display: inline-block;
  font-size: 1.5em;   /* Bigger than text */
  font-weight: normal;
  line-height: 1;
  vertical-align: middle;
  transform: translateY(0.8px);
}

/* Tag chips under notes */
.tagRow{
  margin-top: 8px;
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}

.tagChip{
  font-family: 'Tahoma', sans-serif;
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 999px;
  cursor: pointer;
  user-select: none;

  background: rgba(208, 160, 163, 0.18);
  border: 1px solid rgba(255, 255, 255, 0.55);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  color: #444;
  opacity: 0.9;
}

.tagChip:hover{
  opacity: 1;
  transform: scale(1.03);
}

/* Toolbar + Toggle */
#formatToggle {
  position: fixed;
  bottom: 40px;
  left: 20px;
  font-size: 20px;
  background: rgba(235, 235, 235, 0.25);
  border-radius: 50%;
  width: 44px;
  height: 44px;
  text-align: center;
  line-height: 44px;
  cursor: pointer;
  z-index: 105;
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.4);
  color: #444;
  transition: box-shadow 0.3s ease;
}

#formatToggle:hover {
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.75);
  color: #222;
}

#formatToolbar {
  position: fixed;
  bottom: 80px;
  left: 20px;
  display: none;
  flex-direction: column;
  flex-wrap: nowrap;
  gap: 8px;
  align-items: center;
  justify-content: flex-start;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 10px;
  padding: 5px 6px;
  z-index: 104;
  max-height: 500px;
  max-width: 90vw;
  overflow-x: auto;
  white-space: nowrap;
  -webkit-overflow-scrolling: touch;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  scrollbar-width: none;
  -ms-overflow-style: none;
  color: #444;
}

#formatToolbar.visible { display: flex; }

.format-btn {
  flex: 0 0 auto;
  background: none;
  border: none;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: #444;
  padding: 6px;
  border-radius: 6px;
  opacity: 0.7;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

.format-btn:hover {
  transform: scale(1.2);
  opacity: 1;
  color: #222;
}

.emoji {
  background: none;
  color: #444;
  border: none;
  cursor: pointer;
  opacity: 0.7;
  font-size: 16px;
  transition: all 0.2s ease;
}

.emoji:hover {
  transform: scale(1.2);
  opacity: 1;
}

/* Note Panel */
#noteContainer {
  position: fixed;
  bottom: 40px;
  right: 20px;
  width: 50px;
  height: 50px;
  z-index: 103;
}

/* Click-to-select image + resize handles (JS adds .img-selected) */
.editableNote img,
#noteInput img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 10px 0;
  border-radius: 8px;
}

.img-selected {
  outline: 2px solid rgba(208, 160, 163, 0.9);
  outline-offset: 2px;
}

/* Tiny floating resize panel */
#imgSizePanel {
  position: fixed;
  z-index: 10060;
  display: none;
  gap: 8px;
  align-items: center;
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.45);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.18);
  font-size: 12px;
}

#imgSizePanel input[type="range"] { width: 120px; }
#imgSizePanel input[type="number"] { width: 70px; }
#imgSizePanel button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
  opacity: 0.8;
}
#imgSizePanel button:hover { opacity: 1; }
#addNoteToggle {
  position: fixed;
  width: 50px;
  height: 50px;
  font-size: 28px;
  border-radius: 50%;
  background: rgba(208, 160, 163, 0.3);
  color: #333;
  border: 1px solid rgba(255, 255, 255, 0.4);
  cursor: pointer;
  box-shadow: 0 0 12px rgba(208, 160, 163, 0.5);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  transition: box-shadow 0.3s ease;
}

#addNoteToggle:hover {
  box-shadow: 0 0 20px rgba(208, 160, 163, 0.8);
  color: #222;
}

/* =========================
   Minimal Table Style (FIXED)
========================= */

.cellBox {
  display: block;
  width: 100%;
  min-height: 24px;
  padding: 6px 8px;
  box-sizing: border-box;

  outline: none;
  white-space: pre-wrap;
  word-break: break-word;

  overflow: hidden;      /* hide scrollbars normally */
  resize: none;          /* no resize handle by default */
  background: transparent;
  transition: background 0.15s ease;
}

/* Show resize ONLY when hovering */
.editable-table td:hover .cellBox,
.editable-table th:hover .cellBox {
  resize: both;
  overflow: auto;        /* enable scroll only when resizing */
}

.editable-table {
  border-collapse: collapse;
  border: 1px solid rgba(0,0,0,0.15);
}

.editable-table th,
.editable-table td {
  border: 1px solid rgba(0,0,0,0.10);
  padding: 0;
  background: transparent;
  vertical-align: top;   /* fixes middle vs left issue */
  text-align: left;
}

.editable-table th .cellBox {
  font-weight: 600;
}

table.editable-table{
  width: 100%;
  table-layout: auto;   /* allow natural growth */
  border-collapse: collapse;
}

table.editable-table td{
  vertical-align: top;
}

.cellBox{
  display: block;
  min-height: 0;        /* no forced height */
  padding: 6px 8px;
  white-space: pre-wrap;
  word-break: break-word;
  outline: none;
}

.cellBox {
  display: block;
  width: 100%;
  min-height: 24px;
  padding: 6px 8px;
  box-sizing: border-box;
  outline: none;
  white-space: pre-wrap;
  word-break: break-word;
  overflow: hidden;
  resize: none;
  background: transparent;
}

/* Floating table controls */



#notePanel {
  position: absolute;
  bottom: 60px;
  right: 0;
  width: 300px;
  background: rgba(254, 254, 254, 0.25);
  color: #222;
  border-radius: 12px;
  padding: 16px;
  display: none;
  flex-direction: column;
  gap: 12px;
  box-shadow:
    0 0 6px 1px rgba(220, 230, 255, 0.2),
    0 0 25px 8px rgba(204, 153, 255, 0.2);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.5);
  z-index: 104;
  transition: none;
}

#addNoteBtn {
  background: rgba(236, 235, 232, 0.25);
  color: #3a3a3a;
  border: 1px solid rgba(255, 255, 255, 0.4);
  padding: 10px;
  border-radius: 8px;
  cursor: pointer;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 0 10px rgba(236, 235, 232, 0.4);
  transition: box-shadow 0.3s ease;
}

#addNoteBtn:hover {
  box-shadow: 0 0 16px rgba(236, 235, 232, 0.7);
  color: #222;
}

/* =========================
   Concept pills (INLINE-FRIENDLY)
   - still looks like a pill
   - doesn‚Äôt ‚Äústand off‚Äù inside sentences
========================= */
.chatBubble a.conceptLink,
.editableNote a.conceptLink,
a.conceptLink,
a.conceptLink:visited {
  color: #2a2a2a !important;
  text-decoration: none !important;

  display: inline-flex;           /* key: inline + stable */
  align-items: baseline;          /* keeps text aligned */
  gap: 4px;                       /* space before badge */
  vertical-align: baseline;

  padding: 0 6px;                 /* tighter than before */
  border-radius: 10px;            /* less ‚Äúcapsule‚Äù */

  /* subtle pill by default */
  background: rgba(208, 160, 163, 0.15);
  border: 1px solid rgba(208, 160, 163, 0.22);

  /* flatter so it doesn‚Äôt pop off the line */
  box-shadow: none;

  /* make it readable in sentences */
  line-height: 1.25;
  transform: translateY(0.35px);  /* tiny optical baseline fix */

  cursor: pointer;
  transition:
    background 0.12s ease,
    border-color 0.12s ease,
    box-shadow 0.12s ease,
    transform 0.12s ease;
}

/* Add a super subtle ‚Äúlink cue‚Äù without blue underline */
.chatBubble a.conceptLink,
.editableNote a.conceptLink,
a.conceptLink {
  text-decoration: none !important;
}

/* Hover: more pill + slight lift (only when you interact) */
.chatBubble a.conceptLink:hover,
.editableNote a.conceptLink:hover,
a.conceptLink:hover {
  background: rgba(208, 160, 163, 0.20);
  border-color: rgba(208, 160, 163, 0.40);

  box-shadow:
    0 6px 18px rgba(0,0,0,0.10);

  transform: translateY(-0.5px);
  text-decoration-style: solid;
}

/* Keyboard focus (soft but visible) */
.chatBubble a.conceptLink:focus-visible,
.editableNote a.conceptLink:focus-visible,
a.conceptLink:focus-visible {
  outline: 2px solid rgba(208, 160, 163, 0.35);
  outline-offset: 2px;
}


/* Keyboard focus: visible but still soft */
.chatBubble a.conceptLink:focus-visible,
.editableNote a.conceptLink:focus-visible {
  outline: 2px solid rgba(208, 160, 163, 0.35);
  outline-offset: 2px;
}

/* Concept count badge */
.conceptCount {
  margin-left: 2px;        /* smaller */
  padding: 0 5px;          /* tighter */
  font-size: 9px;
  font-weight: 700;
  border-radius: 999px;
  line-height: 1.2;

  background: rgba(140, 150, 200, 0.18);
  border: 1px solid rgba(140, 150, 200, 0.28);
  color: #444;

  box-shadow: none;
  transform: translateY(-0.5px); /* sits nicer with text */
}

/* Hashtag suggest dropdown */
#tagSuggest {
  position: fixed;
  display: none;
  z-index: 10090;

  min-width: 180px;
  max-width: 70vw;
  max-height: 220px;
  overflow: auto;

  padding: 6px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.55);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.18);

  font-size: 12px;
}

#tagSuggest .item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;

  padding: 6px 10px;
  border-radius: 10px;
  cursor: pointer;
  user-select: none;
  color: #333;
}

#tagSuggest .item:hover,
#tagSuggest .item.active {
  background: rgba(208, 160, 163, 0.22);
}

#tagSuggest .count {
  opacity: 0.65;
  font-size: 11px;
}

/* search highlight color */
.underlineMatch{
  background: rgba(208, 160, 163, 0.25); /* <-- change this */
  color: inherit;
  border-bottom: 1px dotted rgba(0,0,0,0.35);
  padding: 0 2px;
  border-radius: 4px;
}

/* if the browser still applies <mark> defaults */
mark.underlineMatch{
  background: rgba(208, 160, 163, 0.25);
}

/* Floating emoji button + picker */
#floatingEmojiBtn {
  position: fixed;
  display: none;
  z-index: 10050;
  width: 34px;
  height: 34px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.35);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 6px 18px rgba(0,0,0,0.15);
  cursor: pointer;
  user-select: none;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  line-height: 1;
}

#floatingEmojiBtn:hover {
  transform: scale(1.06);
}

#floatingEmojiPanel {
  position: fixed;
  display: none;
  z-index: 10051;
  padding: 8px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.40);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.18);
}

#floatingEmojiPanel .pick {
  width: 30px;
  height: 30px;
  border-radius: 10px;
  border: none;
  background: transparent;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  opacity: 0.85;
}

#floatingEmojiPanel .pick:hover {
  opacity: 1;
  transform: scale(1.12);
}

/* =========================
   Concept Definition Panel
========================= */
#defPanel {
  position: fixed;
  z-index: 10110;
  display: none;
  width: min(360px, 86vw);
  max-height: 60vh;
  overflow: auto;

  padding: 10px 12px;
  border-radius: 14px;

  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.55);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.18);

  color: #222;
  font-family: 'Tahoma', sans-serif;
}

a.conceptLink { 
  position: relative; 
  overflow: visible; 
}

.conceptCount { 
  margin-left: 2px; /* keep your newer tighter spacing */
}

/* Definition badge/dot (NO tooltip) */
a.conceptLink.hasDef::before{
  content: "";
  position: absolute;
  top: -4px;
  right: -4px;

  width: 8px;
  height: 8px;
  border-radius: 999px;

  /* subtle but visible */
  background: rgba(255, 251, 177);
  border: 2px solid rgba(255,255,255,0.85);

  box-shadow: 0 4px 12px rgba(0,0,0,0.12);
  pointer-events: none;
}

#defPanel .topRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  margin-bottom:8px;
}

#defPanel .title {
  font-weight: 700;
  font-size: 12px;
  color: #222;
  display:flex;
  align-items:center;
  gap:8px;
}

#defPanel .hint {
  font-size: 10px;
  opacity: 0.7;
  margin-left: 6px;
  font-weight: 400;
}

#defPanel .closeBtn {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 16px;
  opacity: 0.8;
}
#defPanel .closeBtn:hover { opacity: 1; }

#defBox {
  width: 100%;
  min-height: 44px;
  height: auto;

  overflow: hidden;        /* ‚úÖ no scrollbars inside the box */
  overflow-x: hidden;      /* ‚úÖ kills horizontal bar */

  white-space: pre-wrap;
  word-break: break-word;
  overflow-wrap: anywhere; /* ‚úÖ breaks long strings */

  padding: 10px;
  border-radius: 12px;

  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.35);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  outline: none;
  font-size: 12px;
}

#defPanel { overflow-x: hidden; }

#defBox:empty:before{
  content: "Write a definition‚Ä¶ (saved locally)";
  color: rgba(0,0,0,0.35);
}

#defPanel .btnRow{
  display:flex;
  gap:10px;
  justify-content:flex-end;
  margin-top:10px;
}

#defPanel .miniBtn{
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
  opacity: 0.8;
  padding: 6px 8px;
  border-radius: 10px;

  border: 1px solid rgba(255,255,255,0.45);
  background: rgba(255,255,255,0.22);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

#defPanel .miniBtn:hover{ opacity: 1; }

#defPanel .danger{
  border-color: rgba(208,160,163,0.55);
  background: rgba(208,160,163,0.20);
}

#defTip{
  position: fixed;
  z-index: 999999;
  max-width: min(320px, 70vw);
  padding: 10px 12px;
  border-radius: 12px;
  background: rgba(245, 239, 255);
  border: 1px solid rgba(0,0,0,0.08);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 14px 30px rgba(0,0,0,0.12);
  font-size: 13px;
  line-height: 1.35;
  color: #222;
  pointer-events: none; /* important: don't steal hover/click */
  white-space: pre-wrap;
}

#whyBox {
  width: 100%;
  min-height: 44px;
  height: auto;

  overflow: hidden;
  overflow-x: hidden;

  white-space: pre-wrap;
  word-break: break-word;
  overflow-wrap: anywhere;

  padding: 10px;
  border-radius: 12px;

  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.30);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);

  outline: none;
  font-size: 12px;
  margin-top: 10px;
}

#whyBox:empty:before{
  content: "Why it matters to me‚Ä¶ (saved with the concept)";
  color: rgba(0,0,0,0.35);
}

/* Fullscreen image zoom overlay */
#imgZoomOverlay {
  position: fixed;
  inset: 0;
  z-index: 10080;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(2px);
  -webkit-backdrop-filter: blur(2px);
}

#imgZoomStage {
  width: 92vw;
  height: 92vh;
  overflow: hidden;
  position: relative;
  cursor: grab;
}

#imgZoomStage:active { cursor: grabbing; }

#imgZoomImg {
  position: absolute;
  left: 50%;
  top: 50%;
  transform-origin: center center;
  will-change: transform;
  user-select: none;
  -webkit-user-drag: none;
  max-width: none;
  max-height: none;
  border-radius: 10px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.35);
}

#imgZoomControls {
  position: fixed;
  top: 14px;
  left: 14px;
  z-index: 10081;
  display: none;
  gap: 8px;
  align-items: center;
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(255,255,255,0.18);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  color: #fff;
  font-size: 12px;
}

#imgZoomControls button {
  background: rgba(255,255,255,0.15);
  border: 1px solid rgba(255,255,255,0.25);
  color: #fff;
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
}

#imgZoomControls button:hover { background: rgba(255,255,255,0.25); }
/* Lock UI */
#lockToggle {
  position: fixed;
  top: 12px;
  right: 12px;
  background: #ecebe8;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 15px;
  text-align: center;
  line-height: 40px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  z-index: 200;
}

#lockSection {
  position: fixed;
  top: 60px;
  right: 12px;
  display: none;
  flex-direction: column;
  align-items: flex-end;
  background: rgba(255, 255, 255, 0.95);
  padding: 10px 12px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  gap: 8px;
  z-index: 199;
}

#lockSection input {
  background: #ecebe8;
  color: #333;
  border: 1px solid #ccc;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 10px;
}

#lockSection button {
  background: #d0a0a3;
  color: black;
  border: none;
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 10px;
}

#lockBtn:hover, #unlockBtn:hover { background: #ecebe8; }
#lockInfo { color: #555; font-weight: 100; }

/* Responsive */
@media (max-width: 600px) {
  #chat { padding: 12px 4vw 160px 4vw; }
  #inputArea { width: 70vw; bottom: 30px; }
  #notePanel { width: 90vw; right: 5vw; }
  #lockSection { top: 10px; right: 10px; gap: 6px; } /* fixed from #authSection */
}
</style>


</head>

<body>

<div id="lockToggle" title="Enter access code">üîí</div>

<div id="lockSection">
  <input type="password" id="accessCode" placeholder="Access code" autocomplete="off" />
  <button id="unlockBtn">Unlock</button>
  <button id="lockBtn" style="display:none;" title="Lock">üîí</button>
  <div id="lockInfo">Locked</div>
</div>


<div id="formatToggle">üìã</div>

<div id="formatToolbar">
  <button class="format-btn" id="recallBtn" title="Smart Recall (Shift+Click includes pinned)">üìñ</button>
  <button class="format-btn" id="boldBtn"><b>B</b></button>
  <button class="format-btn" id="italicBtn"><i>I</i></button>
  <button class="format-btn" id="underlineBtn"><u>U</u></button>
  <button class="format-btn" id="indentBtn" title="Indent (Tab) ‚Äî Shift+Click = Outdent">üëâüèª</button>
  <button class="format-btn" id="highlightBtn">üü™</button>
  <button class="format-btn" id="redFontBtn">üü•</button>
  <button class="format-btn" id="blueFontBtn">üü¶</button>

  <button class="format-btn" id="increaseFontBtn" title="Increase Font Size">üî∫A</button>
  <button class="format-btn" id="decreaseFontBtn" title="Decrease Font Size">üîªA</button>

  <button class="format-btn" id="insertTableBtn">üìä</button>
  <button class="format-btn" id="addRowBtn" title="Add Table Row">+R</button>
  <button class="format-btn" id="deleteRowBtn" title="Delete Table Row">-R</button>
  <button class="format-btn" id="addColBtn" title="Add Table Column">+C</button>
  <button class="format-btn" id="deleteColBtn" title="Delete Table Column">-C</button>

  <button class="format-btn" id="resetColorBtn">‚Ü∫</button>

  
</div>

<!-- Container for add button and note panel -->
<div id="noteContainer">
  <button id="addNoteToggle" title="Add Note">Ôºã</button>
  <div id="notePanel" style="display:none; flex-direction: column;">
    <div id="noteInput" contenteditable="true" data-placeholder="Type or paste your note here..."></div>
    <button id="addNoteBtn">Add Note</button>
  </div>
</div>

<!-- Chat area + Live Results go inside this -->
<div id="chat">
  <div id="liveResults"></div>
</div>

<form id="inputArea">
  <input type="text" id="userInput" placeholder='Search‚Ä¶  Tip: Ctrl+L = make [[concept]] (Shift+Click Recall includes pinned)' autocomplete="off" required />
  <button type="submit" id="sendBtn">Send</button>
</form>

<div id="tagSuggest" aria-hidden="true"></div>
<div id="floatingEmojiBtn" title="Insert emoji">üìå</div>
<div id="floatingEmojiPanel" aria-hidden="true"></div>
<div id="defPanel" aria-hidden="true">
  <div class="topRow">
    <div class="title">
      <span id="defTitle">Concept</span>
      <span class="hint">(Shift+Click = definitions)</span>
    </div>
    <button class="closeBtn" id="defCloseBtn" title="Close">‚úï</button>
  </div>

  <div id="defBox" contenteditable="true" data-placeholder="Definition‚Ä¶"></div>

  <div id="whyBox" contenteditable="true" data-placeholder="Why / memory hook‚Ä¶"></div>

  <div class="btnRow">
    <button class="miniBtn" id="defSearchBtn" title="Search this concept">üîé</button>
    <button class="miniBtn danger" id="defDeleteBtn" title="Delete definition">üóëÔ∏è</button>
    <button class="miniBtn" id="defSaveBtn" title="Save definition">üíæ</button>
    <button class="miniBtn" id="defMergeBtn" title="Merge this concept">üß¨</button>
  </div>
</div>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>

<script type="module">
/* =========================
   Firebase init
========================= */
const firebaseConfig = {
  apiKey: "AIzaSyDtv3x9PAMzZUW6yVuUSLgLzA0ejcDidF4",
  authDomain: "notes-chat-c5ff3.firebaseapp.com",
  projectId: "notes-chat-c5ff3",
  storageBucket: "notes-chat-c5ff3.appspot.com",
  messagingSenderId: "597780727252",
  appId: "1:597780727252:web:8407eb4096dbe301d74241",
  measurementId: "G-YQD63H7L5T"
};

firebase.initializeApp(firebaseConfig);

const db = firebase.firestore();
const storage = firebase.storage();
const auth = firebase.auth();
auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);

/* =========================
   DOM refs
========================= */
const chat = document.getElementById('chat');
const liveResults = document.getElementById('liveResults');

const noteInput = document.getElementById('noteInput');
const addNoteBtn = document.getElementById('addNoteBtn');
const addNoteToggle = document.getElementById('addNoteToggle');
const notePanel = document.getElementById('notePanel');

const lockToggle = document.getElementById('lockToggle');
const lockSection = document.getElementById('lockSection');
const accessCodeInput = document.getElementById('accessCode');
const unlockBtn = document.getElementById('unlockBtn');
const lockBtn = document.getElementById('lockBtn');
const lockInfo = document.getElementById('lockInfo');

const inputArea = document.getElementById('inputArea');
const userInput = document.getElementById('userInput');

/* =========================
   Live search cache state
========================= */
let notesCache = [];
let unsubscribeNotes = null;

let unsubscribeDefs = null;         // defs listener
let defsCache = {}; // { normalizedKey: { value: "", why: "", concept: "" } }  (legacy-safe)

let liveTimer = null;
let lastLiveQuery = '';
let tagIndexSorted = [];            // [{tag,count}, ...]
let conceptCountMap = new Map();    // normalizedConcept -> countOfNotesContainingIt
let notesDerived = new Map();       // noteId -> { cleanedHtml, textNorm, tags }

function clearLiveResults() {
  liveResults.innerHTML = '';
}

function renderHeaderLine(text) {
  const header = document.createElement('div');
  header.className = 'message bot';
  const bubble = document.createElement('div');
  bubble.className = 'chatBubble';
  bubble.textContent = 'ü§ñ ' + text;
  header.appendChild(bubble);
  liveResults.appendChild(header);
}

function renderWelcome() {
  clearLiveResults();
  renderHeaderLine('‚úÖ Welcome. Type in the search box to find notes.');
  refreshConceptDefBadges(liveResults);
}

function renderLiveResults(notes, queryLabel) {
  clearLiveResults();
  renderHeaderLine(`Results for: ${queryLabel}`);

  const container = document.createElement('div');
  liveResults.appendChild(container);

  displayNotesInto(container, notes);
  refreshConceptDefBadges(liveResults);
  chat.scrollTo({ top: chat.scrollHeight, behavior: 'smooth' });
}

/* =========================
   Hard error banner (shows real JS errors)
========================= */
function showFatal(msg) {
  clearLiveResults();
  renderHeaderLine('‚ùå ' + msg);
}

window.addEventListener('error', (e) => {
  showFatal(e.message || 'Script error');
});

window.addEventListener('unhandledrejection', (e) => {
  showFatal((e.reason && (e.reason.message || String(e.reason))) || 'Unhandled promise rejection');
});

/* =========================
   Editor state
========================= */
let activeEditable = noteInput;
let isEditingNote = false;
noteInput.addEventListener('focus', () => activeEditable = noteInput);

/* =========================
   Image upload inside notePanel (preview only)
========================= */
const imageUpload = document.createElement('input');
imageUpload.type = 'file';
imageUpload.accept = 'image/*';
imageUpload.id = 'imageUpload';
imageUpload.style.marginTop = '10px';
notePanel.insertBefore(imageUpload, addNoteBtn);

imageUpload.addEventListener('change', function () {
  const file = this.files?.[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    activeEditable.innerHTML += `<br><img src="${e.target.result}" style="width:100%; height:auto; border-radius:8px;" /><br>`;
    placeCaretAtEnd(activeEditable);
    saveCaret();
  };
  reader.readAsDataURL(file);
});

/* =========================
   FIX 1) Keep caret updated in NOTE INPUT too
========================= */
['input','keyup','mouseup','touchend','focus'].forEach(evt => {
  noteInput.addEventListener(evt, () => {
    activeEditable = noteInput;
    saveCaret();
  }, true);
});

// When opening toolbar, keep caret (toggle click can steal focus/selection)
const formatToggle = document.getElementById('formatToggle');
formatToggle.addEventListener('mousedown', (e) => {
  e.preventDefault();
  e.stopPropagation();
  if (activeEditable?.isContentEditable) {
    activeEditable.focus({ preventScroll: true });
    saveCaret();
  }
}, true);

// Prevent toolbar from stealing focus; keep editor active while clicking buttons
const formatToolbar = document.getElementById('formatToolbar');
formatToolbar.addEventListener('mousedown', (e) => {
  if (activeEditable?.isContentEditable) {
    activeEditable.focus({ preventScroll: true });
    saveCaret();
  }
}, true);

/* =========================
   FIX 2) Wire the missing buttons
========================= */

// Indent / Outdent (Shift+Click = outdent)
const indentBtn = document.getElementById('indentBtn');
indentBtn?.addEventListener('mousedown', (e) => {
  e.preventDefault();
  e.stopPropagation();
  runCmd(e.shiftKey ? 'outdent' : 'indent');
}, true);

/* =========================
   Indent UX fix:
   - Backspace at start of an indented block => outdent
   - Enter on an empty indented line => outdent
========================= */

function getClosestBlockEl(node, editor) {
  let el = node?.nodeType === 1 ? node : node?.parentElement;
  while (el && el !== editor) {
    const tag = (el.tagName || '').toLowerCase();
    if (tag === 'blockquote' || tag === 'li' || tag === 'p' || tag === 'div') return el;
    el = el.parentElement;
  }
  return null;
}

function isBlockEmpty(block) {
  if (!block) return true;
  // treat <br> or whitespace as empty
  const text = (block.textContent || '').replace(/\u200B/g, '').trim();
  if (text) return false;

  // if it only contains <br> or empty spans etc, count as empty
  const html = (block.innerHTML || '').replace(/\u200B/g, '').trim().toLowerCase();
  return html === '' || html === '<br>' || html === '<br/>' || html === '<br />' || html === '&nbsp;';
}

function isCaretAtStartOfBlock(range, block) {
  if (!range || !block) return false;

  // If caret is directly in the block and at offset 0
  if (range.startContainer === block && range.startOffset === 0) return true;

  // Otherwise: check if there's any text/content before caret inside this block
  const testRange = document.createRange();
  testRange.setStart(block, 0);
  testRange.setEnd(range.startContainer, range.startOffset);

  const fragText = (testRange.toString() || '').replace(/\u200B/g, '').trim();
  return fragText.length === 0;
}

// Capture key behavior inside editors only
document.addEventListener('keydown', (e) => {
  const editor = getActiveEditor();
  if (!editor) return;

  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return;
  if (!sel.isCollapsed) return;

  const range = sel.getRangeAt(0);
  if (!editor.contains(range.commonAncestorContainer)) return;

  const block = getClosestBlockEl(range.startContainer, editor);
  if (!block) return;

  const tag = (block.tagName || '').toLowerCase();
  const inIndentContext = (tag === 'blockquote') || (tag === 'li');

  // 1) Backspace at start => outdent
  if (e.key === 'Backspace' && inIndentContext && isCaretAtStartOfBlock(range, block)) {
    e.preventDefault();
    // For lists/quotes, outdent usually does the right thing
    document.execCommand('outdent');
    saveCaret();
    return;
  }

  // 2) Enter ALWAYS exits indent
if (e.key === 'Enter' && inIndentContext && !e.shiftKey) {
  e.preventDefault();

  // First create the next line (still inside the current block)
  document.execCommand('insertParagraph');

  // Then immediately step back out (so the new line is not indented)
  document.execCommand('outdent');

  saveCaret();
  return;
}
}, true);

/* =========================
   RESET (selection only): remove formatting + black
========================= */
const resetColorBtn = document.getElementById('resetColorBtn');

resetColorBtn?.addEventListener('mousedown', (e) => {
  e.preventDefault();
  e.stopPropagation();

  const editor = getActiveEditor();
  if (!editor) return;

  editor.focus({ preventScroll: true });
  restoreCaret();

  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return;

  const range = sel.getRangeAt(0);
  if (!editor.contains(range.commonAncestorContainer) || sel.isCollapsed) return;

  document.execCommand('removeFormat');
  document.execCommand('hiliteColor', false, 'transparent');
  document.execCommand('backColor', false, 'transparent');
  document.execCommand('foreColor', false, '#000000');

  saveCaret();
}, true);

/* =========================
   Font size (robust, works on spans + selection)
========================= */
function getSelectionRangeInEditor(editor) {
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) return null;
  const range = sel.getRangeAt(0);
  if (!editor.contains(range.commonAncestorContainer)) return null;
  return range;
}

function clamp(n, min, max) { return Math.max(min, Math.min(max, n)); }

function getFontSizePxFromNode(node, fallbackPx = 12) {
  const el = (node?.nodeType === 1) ? node : node?.parentElement;
  if (!el) return fallbackPx;
  const px = parseFloat(getComputedStyle(el).fontSize);
  return Number.isFinite(px) ? px : fallbackPx;
}

function bumpFontSize(deltaPx) {
  const editor = getActiveEditor();
  if (!editor) return;

  editor.focus({ preventScroll: true });
  restoreCaret();

  const range = getSelectionRangeInEditor(editor);
  if (!range) return;

  const sel = window.getSelection();
  if (!sel || sel.isCollapsed) return;

  if (!editor.contains(range.commonAncestorContainer)) return;

  const selectedText = sel.toString();
  if (!selectedText.trim()) return;

  const startEl = (range.startContainer.nodeType === 1)
    ? range.startContainer
    : range.startContainer.parentElement;

  const sizedSpan = startEl?.closest?.('span[data-fs="1"]') || null;

  if (sizedSpan && editor.contains(sizedSpan)) {
    const spanText = (sizedSpan.innerText || sizedSpan.textContent || '').trim();
    if (spanText && spanText === selectedText.trim()) {
      const cur = parseFloat(sizedSpan.style.fontSize) || getFontSizePxFromNode(sizedSpan, 12);
      const next = clamp(Math.round(cur + deltaPx), 8, 42);
      sizedSpan.style.fontSize = next + 'px';

      const r = document.createRange();
      r.selectNodeContents(sizedSpan);
      sel.removeAllRanges();
      sel.addRange(r);
      saveCaret();
      return;
    }
  }

  const basePx = getFontSizePxFromNode(range.startContainer, parseFloat(getComputedStyle(editor).fontSize) || 12);
  const nextPx = clamp(Math.round(basePx + deltaPx), 8, 42);

  const wrapper = document.createElement('span');
  wrapper.setAttribute('data-fs', '1');
  wrapper.style.fontSize = nextPx + 'px';

  const frag = range.extractContents();
  wrapper.appendChild(frag);
  range.insertNode(wrapper);

  const newRange = document.createRange();
  newRange.selectNodeContents(wrapper);
  sel.removeAllRanges();
  sel.addRange(newRange);

  saveCaret();
}

document.getElementById('increaseFontBtn')?.addEventListener('mousedown', (e) => {
  e.preventDefault(); e.stopPropagation();
  bumpFontSize(+2);
}, true);

document.getElementById('decreaseFontBtn')?.addEventListener('mousedown', (e) => {
  e.preventDefault(); e.stopPropagation();
  bumpFontSize(-2);
}, true);

/* =========================
   Table tools (insert + row/col ops)
========================= */
let lastTableCell = null;

document.addEventListener('focusin', (e) => {
  const cell = e.target?.closest?.('.cellBox');
  if (cell) lastTableCell = cell;
}, true);

document.addEventListener('mousedown', (e) => {
  const cell = e.target?.closest?.('.cellBox');
  if (cell) lastTableCell = cell;
}, true);

function makeTable(rows = 2, cols = 2) {
  const table = document.createElement('table');
  table.className = 'editable-table';
  table.setAttribute('data-editable-table', '1');

  const tbody = document.createElement('tbody');

  for (let r = 0; r < rows; r++) {
    const tr = document.createElement('tr');
    for (let c = 0; c < cols; c++) {
      const td = document.createElement('td');
      const cell = document.createElement('div');
      cell.className = 'cellBox';
      cell.contentEditable = 'true';
      cell.innerHTML = '&nbsp;';
      td.appendChild(cell);
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }

  table.appendChild(tbody);
  return table;
}

function getClosestTableContext() {
  const editor = getActiveEditor();
  if (!editor) return null;

  const sel = window.getSelection();
  const node = sel?.anchorNode || null;

  let el = node ? (node.nodeType === 1 ? node : node.parentElement) : null;

  if (!el || !editor.contains(el)) {
    el = lastTableCell ? lastTableCell : null;
  }

  const cell = el?.closest?.('.cellBox') || null;
  const table = el?.closest?.('table.editable-table') || null;

  return { editor, table, cell };
}

function insertNodeAtCaret(node) {
  const editor = getActiveEditor();
  if (!editor) return;

  editor.focus({ preventScroll: true });
  restoreCaret();

  const sel = window.getSelection();
  if (!sel || !sel.rangeCount) {
    editor.appendChild(node);
    placeCaretAtEnd(editor);
    return;
  }

  const range = sel.getRangeAt(0);
  if (!editor.contains(range.commonAncestorContainer)) {
    editor.appendChild(node);
    placeCaretAtEnd(editor);
    return;
  }

  range.deleteContents();

  const br1 = document.createElement('br');
  const br2 = document.createElement('br');

  range.insertNode(br2);
  range.insertNode(node);
  range.insertNode(br1);

  range.setStartAfter(br2);
  range.collapse(true);

  sel.removeAllRanges();
  sel.addRange(range);

  saveCaret();
}

document.getElementById('insertTableBtn')?.addEventListener('mousedown', (e) => {
  e.preventDefault(); e.stopPropagation();
  const t = makeTable(2, 2);
  insertNodeAtCaret(t);
  setTimeout(() => t.querySelector('.cellBox')?.focus?.(), 0);
}, true);

document.getElementById('addRowBtn')?.addEventListener('mousedown', (e) => {
  e.preventDefault(); e.stopPropagation();
  const ctx = getClosestTableContext();
  if (!ctx?.table) return alert('Click inside a table cell first.');

  const colCount = ctx.table.rows?.[0]?.cells?.length || 0;
  if (!colCount) return;

  const tr = document.createElement('tr');
  for (let c = 0; c < colCount; c++) {
    const td = document.createElement('td');
    const cell = document.createElement('div');
    cell.className = 'cellBox';
    cell.contentEditable = 'true';
    cell.innerHTML = '&nbsp;';
    td.appendChild(cell);
    tr.appendChild(td);
  }
  ctx.table.tBodies[0].appendChild(tr);
}, true);

document.getElementById('deleteRowBtn')?.addEventListener('mousedown', (e) => {
  e.preventDefault(); e.stopPropagation();
  const ctx = getClosestTableContext();
  if (!ctx?.cell || !ctx?.table) return alert('Click inside a table cell first.');

  const td = ctx.cell.closest('td');
  const tr = td?.parentElement;
  if (!tr) return;

  if (ctx.table.rows.length <= 1) return alert('Cannot delete the last row.');
  tr.remove();
}, true);

document.getElementById('addColBtn')?.addEventListener('mousedown', (e) => {
  e.preventDefault(); e.stopPropagation();
  const ctx = getClosestTableContext();
  if (!ctx?.table) return alert('Click inside a table cell first.');

  [...ctx.table.rows].forEach((tr) => {
    const td = document.createElement('td');
    const cell = document.createElement('div');
    cell.className = 'cellBox';
    cell.contentEditable = 'true';
    cell.innerHTML = '&nbsp;';
    td.appendChild(cell);
    tr.appendChild(td);
  });
}, true);

document.getElementById('deleteColBtn')?.addEventListener('mousedown', (e) => {
  e.preventDefault(); e.stopPropagation();
  const ctx = getClosestTableContext();
  if (!ctx?.cell || !ctx?.table) return alert('Click inside a table cell first.');

  const td = ctx.cell.closest('td');
  const tr = td?.parentElement;
  if (!td || !tr) return;

  const colIndex = [...tr.children].indexOf(td);
  const colCount = tr.children.length;

  if (colCount <= 1) return alert('Cannot delete the last column.');

  [...ctx.table.rows].forEach((row) => {
    row.children[colIndex]?.remove?.();
  });
}, true);

/* =========================
   Simple access code gate
========================= */
const ACCESS_CODE = "oatee";
let isUnlocked = (localStorage.getItem('notes_unlocked') === '1');

function setUnlocked(state) {
  isUnlocked = state;
  localStorage.setItem('notes_unlocked', state ? '1' : '0');
  updateUIForLockState();
}

/* =========================
   Image resize UI (EDITING ONLY)
========================= */
let selectedImg = null;

const imgSizePanel = document.createElement('div');
imgSizePanel.id = 'imgSizePanel';
imgSizePanel.innerHTML = `
  <span style="opacity:.8">Size</span>
  <input id="imgSizeRange" type="range" min="10" max="150" value="100" />
  <span id="imgSizePct" style="width:38px; text-align:right;">100%</span>
  <span style="opacity:.8">W</span>
  <input id="imgSizePx" type="number" min="20" step="10" />
  <button id="imgSizeReset" title="Reset" type="button">‚Ü∫</button>
  <button id="imgSizeClose" title="Close" type="button">‚úï</button>
`;
document.body.appendChild(imgSizePanel);

const imgSizeRange = imgSizePanel.querySelector('#imgSizeRange');
const imgSizePct = imgSizePanel.querySelector('#imgSizePct');
const imgSizePx = imgSizePanel.querySelector('#imgSizePx');
const imgSizeReset = imgSizePanel.querySelector('#imgSizeReset');
const imgSizeClose = imgSizePanel.querySelector('#imgSizeClose');

function isEditorImage(img) {
  if (!img || img.tagName !== 'IMG') return false;
  return !!(img.closest('.editableNote') || img.closest('#noteInput'));
}

function showImgPanelAt(img, x, y) {
  const pad = 10;
  imgSizePanel.style.display = 'flex';

  const wStyle = (img.style.width || '').trim();
  const pct = wStyle.endsWith('%') ? parseInt(wStyle, 10) : 100;

  imgSizeRange.value = String(Math.max(10, Math.min(150, pct)));
  imgSizePct.textContent = imgSizeRange.value + '%';

  imgSizePx.value = Math.round(img.getBoundingClientRect().width);

  const panelRect = imgSizePanel.getBoundingClientRect();
  let left = x + pad;
  let top = y + pad;

  if (left + panelRect.width > window.innerWidth - 6) left = window.innerWidth - panelRect.width - 6;
  if (top + panelRect.height > window.innerHeight - 6) top = window.innerHeight - panelRect.height - 6;

  imgSizePanel.style.left = Math.max(6, left) + 'px';
  imgSizePanel.style.top = Math.max(6, top) + 'px';
}

function selectImg(img, x, y) {
  if (selectedImg && selectedImg !== img) selectedImg.classList.remove('img-selected');
  selectedImg = img;
  selectedImg.classList.add('img-selected');
  showImgPanelAt(selectedImg, x, y);
}

function clearImgSelection() {
  if (selectedImg) selectedImg.classList.remove('img-selected');
  selectedImg = null;
  imgSizePanel.style.display = 'none';
}

imgSizeRange.addEventListener('input', () => {
  if (!selectedImg) return;
  const v = parseInt(imgSizeRange.value, 10) || 100;
  imgSizePct.textContent = v + '%';
  selectedImg.style.width = v + '%';
  selectedImg.style.height = 'auto';
  imgSizePx.value = Math.round(selectedImg.getBoundingClientRect().width);
});

imgSizePx.addEventListener('change', () => {
  if (!selectedImg) return;
  const px = parseInt(imgSizePx.value, 10);
  if (!px || px < 20) return;

  selectedImg.style.width = px + 'px';
  selectedImg.style.height = 'auto';

  const parentW = selectedImg.parentElement?.getBoundingClientRect?.().width || px;
  const pct = Math.round((px / parentW) * 100);
  const clamped = Math.max(10, Math.min(150, pct));
  imgSizeRange.value = String(clamped);
  imgSizePct.textContent = clamped + '%';
});

imgSizeReset.addEventListener('click', () => {
  if (!selectedImg) return;
  selectedImg.style.width = '100%';
  selectedImg.style.height = 'auto';
  imgSizeRange.value = '100';
  imgSizePct.textContent = '100%';
  imgSizePx.value = Math.round(selectedImg.getBoundingClientRect().width);
});

imgSizeClose.addEventListener('click', clearImgSelection);

document.addEventListener('click', (e) => {
  const t = e.target;

  if (t && t.tagName === 'IMG' && isEditorImage(t)) {
    e.preventDefault();
    e.stopPropagation();
    selectImg(t, e.clientX, e.clientY);
    return;
  }

  if (!imgSizePanel.contains(e.target)) clearImgSelection();
}, true);

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') clearImgSelection();
}, true);

/* =========================
   Image zoom viewer (VIEW MODE ONLY)
========================= */
const imgZoomOverlay = document.createElement('div');
imgZoomOverlay.id = 'imgZoomOverlay';
imgZoomOverlay.innerHTML = `
  <div id="imgZoomControls">
    <button type="button" id="zoomOutBtn">‚àí</button>
    <button type="button" id="zoomInBtn">Ôºã</button>
    <button type="button" id="zoomResetBtn">Reset</button>
    <button type="button" id="zoomCloseBtn">Close</button>
  </div>
  <div id="imgZoomStage">
    <img id="imgZoomImg" alt="" />
  </div>
`;
document.body.appendChild(imgZoomOverlay);

const imgZoomControls = imgZoomOverlay.querySelector('#imgZoomControls');
const imgZoomStage = imgZoomOverlay.querySelector('#imgZoomStage');
const imgZoomImg = imgZoomOverlay.querySelector('#imgZoomImg');

const zoomInBtn = imgZoomOverlay.querySelector('#zoomInBtn');
const zoomOutBtn = imgZoomOverlay.querySelector('#zoomOutBtn');
const zoomResetBtn = imgZoomOverlay.querySelector('#zoomResetBtn');
const zoomCloseBtn = imgZoomOverlay.querySelector('#zoomCloseBtn');

let zoomOpen = false;
let zScale = 1;
let zX = 0;
let zY = 0;
let isPanning = false;
let panStartX = 0;
let panStartY = 0;

function applyZoomTransform() {
  imgZoomImg.style.transform =
    `translate(-50%, -50%) translate(${zX}px, ${zY}px) scale(${zScale})`;
}

function fitZoomToStage() {
  const stageRect = imgZoomStage.getBoundingClientRect();
  const iw = imgZoomImg.naturalWidth || 1;
  const ih = imgZoomImg.naturalHeight || 1;

  const scaleX = (stageRect.width * 0.98) / iw;
  const scaleY = (stageRect.height * 0.98) / ih;
  zScale = Math.min(scaleX, scaleY);

  zX = 0;
  zY = 0;

  applyZoomTransform();
}

function zoomBy(factor, centerClientX, centerClientY) {
  const newScale = Math.max(0.1, Math.min(8, zScale * factor));
  if (newScale === zScale) return;

  const stageRect = imgZoomStage.getBoundingClientRect();
  const stageCX = stageRect.left + stageRect.width / 2;
  const stageCY = stageRect.top + stageRect.height / 2;

  const mx = (centerClientX ?? stageCX) - stageCX;
  const my = (centerClientY ?? stageCY) - stageCY;

  const px = (mx - zX) / zScale;
  const py = (my - zY) / zScale;

  zScale = newScale;

  zX = mx - px * zScale;
  zY = my - py * zScale;

  applyZoomTransform();
}

function openZoom(src) {
  zoomOpen = true;

  imgZoomImg.src = src;
  imgZoomOverlay.style.display = 'flex';
  imgZoomControls.style.display = 'flex';

  zScale = 1;
  zX = 0;
  zY = 0;

  imgZoomImg.onload = () => {
    requestAnimationFrame(() => requestAnimationFrame(fitZoomToStage));
  };

  requestAnimationFrame(applyZoomTransform);
}

function closeZoom() {
  zoomOpen = false;
  imgZoomOverlay.style.display = 'none';
  imgZoomControls.style.display = 'none';
  imgZoomImg.src = '';
}

zoomInBtn.addEventListener('click', () => zoomBy(1.2));
zoomOutBtn.addEventListener('click', () => zoomBy(1 / 1.2));
zoomResetBtn.addEventListener('click', () => fitZoomToStage());
zoomCloseBtn.addEventListener('click', () => closeZoom());

imgZoomOverlay.addEventListener('click', (e) => {
  if (e.target === imgZoomOverlay) closeZoom();
});

imgZoomStage.addEventListener('wheel', (e) => {
  if (!zoomOpen) return;
  e.preventDefault();
  const factor = e.deltaY < 0 ? 1.12 : 1 / 1.12;
  zoomBy(factor, e.clientX, e.clientY);
}, { passive: false });

imgZoomStage.addEventListener('mousedown', (e) => {
  if (!zoomOpen) return;
  isPanning = true;

  const stageRect = imgZoomStage.getBoundingClientRect();
  const stageCX = stageRect.left + stageRect.width / 2;
  const stageCY = stageRect.top + stageRect.height / 2;

  panStartX = (e.clientX - stageCX) - zX;
  panStartY = (e.clientY - stageCY) - zY;
});

window.addEventListener('mousemove', (e) => {
  if (!zoomOpen || !isPanning) return;

  const stageRect = imgZoomStage.getBoundingClientRect();
  const stageCX = stageRect.left + stageRect.width / 2;
  const stageCY = stageRect.top + stageRect.height / 2;

  zX = (e.clientX - stageCX) - panStartX;
  zY = (e.clientY - stageCY) - panStartY;

  applyZoomTransform();
});

window.addEventListener('mouseup', () => {
  isPanning = false;
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && zoomOpen) closeZoom();
}, true);

function isViewingNoteImage(img) {
  if (!img || img.tagName !== 'IMG') return false;
  const inBubble = !!img.closest('.chatBubble');
  const inEditor = !!(img.closest('.editableNote') || img.closest('#noteInput'));
  return inBubble && !inEditor;
}

document.addEventListener('click', (e) => {
  const t = e.target;
  if (t && t.tagName === 'IMG' && isViewingNoteImage(t)) {
    e.preventDefault();
    e.stopPropagation();
    openZoom(t.src);
  }
}, true);

/* =========================
   UI lock state
========================= */
function updateUIForLockState() {
  if (isUnlocked) {
    lockInfo.textContent = "Unlocked";
    lockToggle.textContent = "üîì";
    lockToggle.title = "Unlocked";

    unlockBtn.style.display = "none";
    lockBtn.style.display = "inline-block";
    accessCodeInput.style.display = "none";

    addNoteToggle.style.display = 'inline-block';
    notePanel.style.display = 'none';

    startNotesListener();
    startDefsListener(); // ‚úÖ defs listener STARTS here

  } else {
    lockInfo.textContent = "Locked";
    lockToggle.textContent = "üîí";
    lockToggle.title = "Enter access code";

    unlockBtn.style.display = "inline-block";
    lockBtn.style.display = "none";
    accessCodeInput.style.display = "inline-block";
    accessCodeInput.value = "";

    addNoteToggle.style.display = 'none';
    notePanel.style.display = 'none';

    stopNotesListener();
    stopDefsListener(); // ‚úÖ defs listener STOPS here
  }
}

/* =========================
   Smart Recall (your existing code)
========================= */
const recallBtn = document.getElementById('recallBtn');

const SEEN_KEY = 'notes_seen_v1';
let seenMap = {};
try { seenMap = JSON.parse(localStorage.getItem(SEEN_KEY) || '{}') || {}; } catch { seenMap = {}; }
function saveSeenMap(){ try { localStorage.setItem(SEEN_KEY, JSON.stringify(seenMap)); } catch {} }
function getSeenAt(noteId){ return Number(seenMap[noteId] || 0); }
function markSeen(noteId){ seenMap[noteId] = Date.now(); saveSeenMap(); }

function pickWeightedUnique(items, k) {
  const pool = items.slice();
  const picked = [];
  for (let i = 0; i < k && pool.length; i++) {
    const total = pool.reduce((sum, x) => sum + x.weight, 0);
    let r = Math.random() * (total || 1);
    let idx = 0;
    for (; idx < pool.length; idx++) {
      r -= pool[idx].weight;
      if (r <= 0) break;
    }
    idx = Math.min(idx, pool.length - 1);
    picked.push(pool[idx]);
    pool.splice(idx, 1);
  }
  return picked;
}

function runSmartRecall({ count = 3, includePinned = false } = {}) {
  if (!isUnlocked) return alert('Locked.');

  if (!notesCache.length) {
    clearLiveResults();
    renderHeaderLine('üìñ Smart Recall: no notes yet.');
    return;
  }

  const now = Date.now();
  const DAY = 86400000;

  const candidates = notesCache
    .filter(n => includePinned ? true : !n.pinned)
    .map(n => {
      const seenAt = getSeenAt(n.id);
      const daysSinceSeen = seenAt ? (now - seenAt) / DAY : 999;

      const weight =
        !seenAt ? 12 :
        daysSinceSeen > 30 ? 10 :
        daysSinceSeen > 14 ? 7 :
        daysSinceSeen > 7  ? 4 :
        daysSinceSeen > 3  ? 2 :
        0.8;

      return {
        id: n.id,
        createdAt: n.createdAt,
        content: n.content || '',
        pinned: !!n.pinned,
        weight
      };
    });

  const chosen = pickWeightedUnique(candidates, count);
  chosen.forEach(n => markSeen(n.id));

  clearLiveResults();
  renderHeaderLine(`üìñ Smart Recall (${chosen.length})`);

  const container = document.createElement('div');
  liveResults.appendChild(container);

  displayNotesInto(container, chosen.map(n => ({
    id: n.id,
    createdAt: n.createdAt,
    content: stripLegacyTableControls(n.content),
    pinned: n.pinned,
    score: 0
  })));

  refreshConceptDefBadges(liveResults);
  chat.scrollTo({ top: chat.scrollHeight, behavior: 'smooth' });
}

if (recallBtn) {
  recallBtn.addEventListener('click', (e) => {
    recallBtn.style.opacity = '1';
    setTimeout(() => (recallBtn.style.opacity = ''), 250);
    runSmartRecall({ count: 3, includePinned: e.shiftKey });
  });
}

document.addEventListener('keydown', (e) => {
  if (!isUnlocked) return;
  if (e.altKey && (e.key === 'r' || e.key === 'R')) {
    e.preventDefault();
    runSmartRecall({ count: 3, includePinned: e.shiftKey });
  }
});

/* =========================
   Cache derivations (your existing)
========================= */
function buildDerivedCachesFromNotes() {
  notesDerived.clear();
  conceptCountMap = new Map();

  const tagMap = new Map();

  for (const n of notesCache) {
    const cleanedHtml = stripLegacyTableControls(n.content || '');
    const plainText = htmlToText(cleanedHtml);
    const textNorm = normalizeText(plainText);

    const tags = extractTagsFromHtml(cleanedHtml);

    for (const t of tags) tagMap.set(t, (tagMap.get(t) || 0) + 1);

    const conceptsSet = new Set();
    const re = /\[\[([^\]\[]+?)\]\]/g;
    let m;
    while ((m = re.exec(plainText)) !== null) {
      const concept = (m[1] || '').trim();
      if (!concept) continue;
      conceptsSet.add(normalizeText(concept));
    }

    for (const c of conceptsSet) {
      conceptCountMap.set(c, (conceptCountMap.get(c) || 0) + 1);
    }

    notesDerived.set(n.id, { cleanedHtml, textNorm, tags });
  }

  tagIndexSorted = [...tagMap.entries()]
    .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0]))
    .map(([tag, count]) => ({ tag, count }));
}

function deLinkifyConceptAnchors(html) {
  const div = document.createElement('div');
  div.innerHTML = html || '';

  div.querySelectorAll('a.conceptLink').forEach(a => {
    const concept = (a.getAttribute('data-concept') || a.textContent || '').trim();
    a.replaceWith(document.createTextNode(`[[${concept}]]`));
  });

  return div.innerHTML;
}

/* =========================
   Notes listener (FIXED: no defs listener here)
========================= */
function startNotesListener() {
  if (!isUnlocked) return;
  if (unsubscribeNotes) unsubscribeNotes();

  unsubscribeNotes = db.collection('notes')
    .onSnapshot((snap) => {
      notesCache = snap.docs.map(d => ({ id: d.id, ...d.data() }));

      notesCache.sort((a, b) => {
        const ta = a.createdAt?.toMillis?.() || 0;
        const tb = b.createdAt?.toMillis?.() || 0;
        return tb - ta;
      });

      buildDerivedCachesFromNotes();

      if (isEditingNote) return;

      const q = userInput.value.trim();
      if (q) runLiveSearch(q, true);
      else renderWelcome();

    }, (err) => {
      console.error('Notes listener error:', err);
      showFatal('Firestore: ' + (err?.message || err));
    });
}

function stopNotesListener() {
  if (unsubscribeNotes) {
    unsubscribeNotes();
    unsubscribeNotes = null;
  }
  notesCache = [];
  clearLiveResults();
}

/* =========================
   Definitions listener (FIXED: loads {value, why, concept})
========================= */
function startDefsListener() {
  if (!isUnlocked) return;
  if (unsubscribeDefs) unsubscribeDefs();

  ensureSignedIn().then(() => {
    if (!isUnlocked) return;

    unsubscribeDefs = db.collection('concept_defs')
      .onSnapshot((snap) => {
        const next = {};
        snap.forEach(doc => {
          const d = doc.data() || {};

          // legacy-safe: if earlier docs stored just "value" string in your old cache shape
          const value = typeof d.value === 'string' ? d.value : '';
          const why   = typeof d.why === 'string' ? d.why : '';
          const concept = typeof d.concept === 'string' ? d.concept : '';

          next[doc.id] = { value, why, concept };
        });

        defsCache = next;

        refreshConceptDefBadges(liveResults);
      }, (err) => {
        console.error('Defs listener error:', err);
      });
  });
}

function stopDefsListener() {
  if (unsubscribeDefs) {
    unsubscribeDefs();
    unsubscribeDefs = null;
  }
  defsCache = {};
}

/* =========================
   Caret save/restore (PER-EDITOR)
========================= */
const caretMap = new WeakMap(); // editorEl -> Range

function saveCaret() {
  const sel = window.getSelection();
  if (!sel || !sel.rangeCount || !activeEditable) return;

  const r = sel.getRangeAt(0);
  if (activeEditable.contains(r.startContainer)) {
    caretMap.set(activeEditable, r.cloneRange());
  }
}

function restoreCaret() {
  if (!activeEditable) return false;
  const r = caretMap.get(activeEditable);
  if (!r) return false;
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(r);
  return true;
}

function placeCaretAtEnd(el) {
  el.focus();
  const range = document.createRange();
  range.selectNodeContents(el);
  range.collapse(false);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
  caretMap.set(el, range.cloneRange());
}

/* =========================
   Notes panel toggle
========================= */
addNoteToggle.onclick = () => {
  notePanel.style.display = (notePanel.style.display === 'flex') ? 'none' : 'flex';
  activeEditable = noteInput;
  noteInput.focus();
};

/* =========================
   Inline Emoji Picker (your existing)
========================= */
const floatingEmojiPanel = document.getElementById('floatingEmojiPanel');
const EMOJIS = ['¬∞','üî¥','üü†','üü°','üü¢','üîµ','üü£','‚ö´Ô∏è','‚ö™Ô∏è','‚ûú','‚¨áÔ∏é','‚¨Ö','‚ûú ','‚úÖ','‚ùå','‚≠ê','üî•','ü¶†','‚óºÔ∏è','‚ù§Ô∏è','üß†','üå°Ô∏è','üìù','üìå','üìç','üíä','‚ö†Ô∏è','üö®','‚è≥','üí•','üí™üèª'];

function hideEmojiPanel() {
  floatingEmojiPanel.style.display = 'none';
  floatingEmojiPanel.setAttribute('aria-hidden', 'true');
  floatingEmojiPanel.innerHTML = '';
}

function showEmojiPanelNearButton(btnEl, onPick) {
  floatingEmojiPanel.innerHTML = '';
  EMOJIS.forEach(e => {
    const b = document.createElement('button');
    b.type = 'button';
    b.className = 'pick';
    b.textContent = e;
    b.addEventListener('click', (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      onPick(e);
      hideEmojiPanel();
    });
    floatingEmojiPanel.appendChild(b);
  });

  const r = btnEl.getBoundingClientRect();
  const pad = 8;

  floatingEmojiPanel.style.display = 'block';
  floatingEmojiPanel.setAttribute('aria-hidden', 'false');

  const left = Math.min(window.innerWidth - 10, r.right + pad);
  const top = Math.min(window.innerHeight - 10, r.top);

  floatingEmojiPanel.style.left = left + 'px';
  floatingEmojiPanel.style.top = top + 'px';
}

document.addEventListener('mousedown', (e) => {
  if (floatingEmojiPanel.style.display !== 'block') return;
  if (floatingEmojiPanel.contains(e.target)) return;
  hideEmojiPanel();
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') hideEmojiPanel();
});

function insertEmojiAtCaret(emoji) {
  if (!activeEditable) return;

  activeEditable.focus();
  restoreCaret();

  const sel = window.getSelection();
  if (sel && sel.rangeCount && activeEditable.contains(sel.anchorNode)) {
    const range = sel.getRangeAt(0);
    range.deleteContents();

    const span = document.createElement('span');
    span.className = 'resizableEmoji';
    span.textContent = emoji;

    range.insertNode(span);

    const spacer = document.createTextNode('\u200B');
    span.after(spacer);

    range.setStartAfter(spacer);
    range.collapse(true);

    sel.removeAllRanges();
    sel.addRange(range);

    saveCaret();
  } else {
    activeEditable.appendChild(document.createTextNode(emoji));
    placeCaretAtEnd(activeEditable);
  }
}

/* =========================
   Linkify
========================= */
function linkify(html) {
  const div = document.createElement('div');
  div.innerHTML = html;

  const walker = document.createTreeWalker(div, NodeFilter.SHOW_TEXT, null);
  const urlRegex = /\bhttps?:\/\/[^\s<]+/gi;

  const textNodes = [];
  while (walker.nextNode()) textNodes.push(walker.currentNode);

  textNodes.forEach(node => {
    const text = node.nodeValue;
    if (!urlRegex.test(text)) return;

    const frag = document.createDocumentFragment();
    let lastIndex = 0;
    text.replace(urlRegex, (match, offset) => {
      frag.appendChild(document.createTextNode(text.slice(lastIndex, offset)));
      const a = document.createElement('a');
      a.href = match;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      a.textContent = match;
      frag.appendChild(a);
      lastIndex = offset + match.length;
      return match;
    });
    frag.appendChild(document.createTextNode(text.slice(lastIndex)));

    node.parentNode.replaceChild(frag, node);
  });

  return div.innerHTML;
}

/* =========================
   Add note
========================= */
addNoteBtn.onclick = async () => {
  if (!isUnlocked) return alert('Locked.');

  const raw = noteInput.innerHTML.trim();
  const noteContent = deLinkifyConceptAnchors(linkify(raw));

  if (!noteContent || noteContent === '<br>') return alert('Note is required.');

  addNoteBtn.disabled = true;
  addNoteBtn.textContent = 'Adding...';

  try {
    await ensureSignedIn();
    await db.collection('notes').add({
      content: noteContent,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    });

    noteInput.innerHTML = '';
    imageUpload.value = '';
    notePanel.style.display = 'none';

    const q = userInput.value.trim();
    if (q) runLiveSearch(q, true);
    else renderLiveResults(notesCache.slice(0, 30), 'Latest notes');

  } catch (e) {
    alert('Error: ' + e.message);
  } finally {
    addNoteBtn.disabled = false;
    addNoteBtn.textContent = 'Add Note';
  }
};

async function ensureSignedIn() {
  if (auth.currentUser) return auth.currentUser;

  await new Promise((resolve) => {
    const unsub = auth.onAuthStateChanged(() => {
      unsub();
      resolve();
    });
  });

  if (auth.currentUser) return auth.currentUser;

  try {
    await auth.signInAnonymously();
    console.log("Signed in uid:", auth.currentUser?.uid);
    return auth.currentUser;
  } catch (e) {
    console.error("Anonymous sign-in failed:", e);
    throw e;
  }
}

function stripLegacyTableControls(html) {
  if (!html) return '';
  return html
    .replace(/<button[^>]*class="table-control-toggle"[\s\S]*?<\/button>/gi, '')
    .replace(/<div[^>]*class="table-control-panel"[\s\S]*?<\/div>/gi, '')
    .replace(/<button[^>]*class="table-btn"[\s\S]*?<\/button>/gi, '');
}

/* =========================
   "AI" placeholder (only used if you type /ask ...)
========================= */
async function askAI(question) {
  await new Promise(res => setTimeout(res, 250));
  return `You asked:\n${question}`;
}

/* =========================
   Search helpers
========================= */
function normalizeText(s) {
  return (s || '')
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .trim();
}

function htmlToText(html) {
  const div = document.createElement('div');
  div.innerHTML = html || '';
  return div.textContent || div.innerText || '';
}

function normalizeTag(s) {
  return (s || '')
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .trim();
}

function extractTagsFromHtml(html) {
  const text = htmlToText(html || '');
  const re = /(^|[\s(>])#([a-zA-Z0-9_][a-zA-Z0-9_-]*)/g;
  const tags = [];
  let m;

  while ((m = re.exec(text)) !== null) {
    const tag = normalizeTag(m[2]);
    if (tag && !tags.includes(tag)) tags.push(tag);
  }
  return tags;
}

function parseFindQuery(raw) {
  const s = raw.replace(/^\/find\s+/i, '').trim();

  const phrases = [];
  const quoteRegex = /"([^"]+)"/g;
  let m;
  while ((m = quoteRegex.exec(s)) !== null) {
    const p = m[1].trim();
    if (p) phrases.push(p);
  }

  const remainder = s.replace(quoteRegex, ' ').split(',')
    .map(t => t.trim())
    .filter(Boolean);

  const terms = [...phrases, ...remainder].filter(Boolean);

  return { raw: s, terms: terms.map(normalizeText).filter(Boolean) };
}

function scoreDoc(textNorm, termsNorm) {
  let score = 0;
  for (const t of termsNorm) {
    if (!t) continue;
    if (textNorm.startsWith(t)) score += 6;

    const wholeWord = new RegExp(`\\b${t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
    if (wholeWord.test(textNorm)) score += 3;

    if (textNorm.includes(t)) score += 1;
  }
  return score;
}

function highlightHTML(html, termsNorm) {
  if (!termsNorm?.length) return html;

  const container = document.createElement('div');
  container.innerHTML = html;

  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
  const nodes = [];
  while (walker.nextNode()) nodes.push(walker.currentNode);

  const escaped = termsNorm
    .filter(Boolean)
    .sort((a, b) => b.length - a.length)
    .map(t => t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));

  if (!escaped.length) return html;
  const regex = new RegExp(`(${escaped.join('|')})`, 'gi');

  nodes.forEach(node => {
    const parent = node.parentElement;
    if (parent && parent.closest('a.conceptLink')) return;

    const text = node.nodeValue;
    if (!regex.test(text)) return;

    const span = document.createElement('span');
    span.innerHTML = text.replace(regex, `<mark class="underlineMatch">$1</mark>`);
    node.parentNode.replaceChild(span, node);
  });

  return container.innerHTML;
}

/* =========================
   Cache-based query (SYNC + stable)
========================= */
function queryNotesSync(rawQuery) {
  if (!isUnlocked) return [];

  const { terms } = parseFindQuery(rawQuery);
  if (!terms.length) return notesCache.slice(0, 30);

  const results = [];

  for (const data of notesCache) {
    const originalHtml = data.content || '';
    const cleanedHtml = stripLegacyTableControls(originalHtml);

    const textNorm = normalizeText(htmlToText(cleanedHtml));
    const tags = extractTagsFromHtml(cleanedHtml);

    const ok = terms.every(t => {
      if (!t) return true;

      if (t.startsWith('#')) {
        const tagTerm = normalizeTag(t.slice(1));
        if (!tagTerm) return true;
        return tags.some(tag => tag === tagTerm || tag.startsWith(tagTerm));
      }

      const esc = t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      const whole = new RegExp(`\\b${esc}\\b`, 'i');
      return whole.test(htmlToText(cleanedHtml));
    });

    if (!ok) continue;

    const withConcepts = conceptLinkifyHTML(cleanedHtml);
    const withHighlights = highlightHTML(withConcepts, terms);

    results.push({
      id: data.id,
      createdAt: data.createdAt,
      content: withHighlights,
      score: scoreDoc(textNorm, terms)
    });
  }

  results.sort((a, b) => {
    const s = b.score - a.score;
    if (s !== 0) return s;
    const ta = a.createdAt?.toMillis?.() || 0;
    const tb = b.createdAt?.toMillis?.() || 0;
    return tb - ta;
  });

  return results.slice(0, 30);
}

/* =========================
   Inline image picker for edit mode
========================= */
function insertImageAtCaret(dataUrl) {
  if (!activeEditable) return;
  restoreCaret();

  const img = document.createElement('img');
  img.src = dataUrl;
  img.style.width = '100%';
  img.style.height = 'auto';
  img.style.borderRadius = '8px';

  const sel = window.getSelection();
  if (sel && sel.rangeCount && activeEditable.contains(sel.anchorNode)) {
    const range = sel.getRangeAt(0);
    range.deleteContents();

    const br1 = document.createElement('br');
    const br2 = document.createElement('br');

    range.insertNode(br2);
    range.insertNode(img);
    range.insertNode(br1);

    range.setStartAfter(br2);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);

    saveCaret();
  } else {
    activeEditable.appendChild(document.createElement('br'));
    activeEditable.appendChild(img);
    activeEditable.appendChild(document.createElement('br'));
    placeCaretAtEnd(activeEditable);
  }
}

function makeInlineImagePickerButton(onPicked) {
  const wrap = document.createElement('span');

  const pickBtn = document.createElement('button');
  pickBtn.type = 'button';
  pickBtn.textContent = 'üñºÔ∏è';

  Object.assign(pickBtn.style, {
    background: 'none',
    border: 'none',
    color: '#666',
    fontSize: '16px',
    cursor: 'pointer',
    marginRight: '12px'
  });

  const file = document.createElement('input');
  file.type = 'file';
  file.accept = 'image/*';
  file.style.display = 'none';

  pickBtn.addEventListener('click', () => file.click());

  file.addEventListener('change', () => {
    const f = file.files?.[0];
    if (!f) return;

    const reader = new FileReader();
    reader.onload = (e) => {
      const dataUrl = e.target?.result;
      if (typeof dataUrl === 'string') onPicked(dataUrl);
      file.value = '';
    };
    reader.readAsDataURL(f);
  });

  wrap.appendChild(pickBtn);
  wrap.appendChild(file);
  return wrap;
}

/* =========================
   Concept Definitions (Firestore-backed)
========================= */
function defKeyForConcept(concept) {
  return normalizeText(concept || '');
}

// legacy-safe getters: handle both {value,why} objects and old string cache entries
function getDefinition(concept) {
  const k = defKeyForConcept(concept);
  const v = defsCache[k];
  if (!v) return '';
  if (typeof v === 'string') return v;
  return (v?.value) || '';
}

function getWhy(concept) {
  const k = defKeyForConcept(concept);
  const v = defsCache[k];
  if (!v || typeof v === 'string') return '';
  return (v?.why) || '';
}

async function setDefinition(concept, value, why) {
  const k = defKeyForConcept(concept);
  if (!k) return;

  await ensureSignedIn();

  await db.collection('concept_defs').doc(k).set({
    concept: (concept || '').trim(),
    value: (value || '').trim(),
    why: (why || '').trim(),
    updatedAt: firebase.firestore.FieldValue.serverTimestamp()
  }, { merge: true });
}

async function deleteDefinition(concept) {
  const k = defKeyForConcept(concept);
  if (!k) return;

  await ensureSignedIn();
  await db.collection('concept_defs').doc(k).delete();
}

function refreshConceptDefBadges(root = document) {
  const links = root.querySelectorAll('a.conceptLink');
  links.forEach(a => {
    const concept = (a.getAttribute('data-concept') || a.textContent || '').trim();
    const def = (getDefinition(concept) || '').trim();

    if (def) {
      a.classList.add('hasDef');
      a.setAttribute('data-def', def);
    } else {
      a.classList.remove('hasDef');
      a.removeAttribute('data-def');
    }
  });
}

/* =========================
   Definition panel wiring (FIXED + stable + MERGE)
   NOTE: your HTML must include:
   - #defPanel #defTitle #defBox #whyBox #defCloseBtn #defSaveBtn #defDeleteBtn #defSearchBtn #defMergeBtn
========================= */
const defPanel = document.getElementById('defPanel');
const defTitle = document.getElementById('defTitle');
const defBox = document.getElementById('defBox');
const whyBox = document.getElementById('whyBox'); // may be null if not added yet
const defCloseBtn = document.getElementById('defCloseBtn');
const defSaveBtn = document.getElementById('defSaveBtn');
const defDeleteBtn = document.getElementById('defDeleteBtn');
const defSearchBtn = document.getElementById('defSearchBtn');
const defMergeBtn = document.getElementById('defMergeBtn');

let currentDefConcept = '';

/* =========================
   Floating definition tooltip (always above tables)
========================= */
const defTip = document.createElement('div');
defTip.id = 'defTip';
defTip.style.display = 'none';
document.body.appendChild(defTip);

let tipOpen = false;

function showDefTip(text, x, y) {
  if (!text) return;
  defTip.textContent = text;
  defTip.style.display = 'block';
  tipOpen = true;

  const pad = 12;
  const r = defTip.getBoundingClientRect();

  let left = x + pad;
  let top = y + pad;

  if (left + r.width > window.innerWidth - 10) left = window.innerWidth - r.width - 10;
  if (top + r.height > window.innerHeight - 10) top = window.innerHeight - r.height - 10;

  defTip.style.left = Math.max(10, left) + 'px';
  defTip.style.top = Math.max(10, top) + 'px';
}

function hideDefTip() {
  tipOpen = false;
  defTip.style.display = 'none';
  defTip.textContent = '';
}

document.addEventListener('mousemove', (e) => {
  if (!tipOpen) return;
  // gently follow mouse so it feels natural
  showDefTip(defTip.textContent, e.clientX, e.clientY);
}, true);

// Use capture so tables/cells don‚Äôt swallow hover
document.addEventListener('mouseover', (e) => {
  const a = e.target.closest?.('a.conceptLink.hasDef');
  if (!a) return;

  const text = (a.getAttribute('data-def') || '').trim();
  if (!text) return;

  showDefTip(text, e.clientX, e.clientY);
}, true);

document.addEventListener('mouseout', (e) => {
  const from = e.target.closest?.('a.conceptLink.hasDef');
  if (!from) return;

  // if moving to another link, don‚Äôt hide
  const to = e.relatedTarget?.closest?.('a.conceptLink.hasDef');
  if (to) return;

  hideDefTip();
}, true);

document.addEventListener('scroll', hideDefTip, true);
document.addEventListener('keydown', (e) => { if (e.key === 'Escape') hideDefTip(); }, true);

function autoGrowBox(el) {
  if (!el) return;
  el.style.height = 'auto';
  el.style.height = (el.scrollHeight + 2) + 'px';
}

defBox?.addEventListener('input', () => autoGrowBox(defBox));
defBox?.addEventListener('paste', () => setTimeout(() => autoGrowBox(defBox), 0));
whyBox?.addEventListener('input', () => autoGrowBox(whyBox));
whyBox?.addEventListener('paste', () => setTimeout(() => autoGrowBox(whyBox), 0));

function openDefPanel(concept, clientX, clientY) {
  currentDefConcept = (concept || '').trim();
  if (!currentDefConcept) return;

  if (defTitle) defTitle.textContent = currentDefConcept;

  if (defBox) defBox.textContent = getDefinition(currentDefConcept);
  if (whyBox) whyBox.textContent = getWhy(currentDefConcept);

  autoGrowBox(defBox);
  autoGrowBox(whyBox);

  if (!defPanel) return;

  defPanel.style.display = 'block';
  defPanel.setAttribute('aria-hidden', 'false');

  const pad = 10;
  const rect = defPanel.getBoundingClientRect();
  let left = (clientX ?? 80) + pad;
  let top = (clientY ?? 80) + pad;

  if (left + rect.width > window.innerWidth - 10) left = window.innerWidth - rect.width - 10;
  if (top + rect.height > window.innerHeight - 10) top = window.innerHeight - rect.height - 10;

  defPanel.style.left = Math.max(10, left) + 'px';
  defPanel.style.top = Math.max(10, top) + 'px';

  setTimeout(() => defBox?.focus?.({ preventScroll: true }), 0);
}

function closeDefPanel() {
  if (!defPanel) return;
  defPanel.style.display = 'none';
  defPanel.setAttribute('aria-hidden', 'true');
  currentDefConcept = '';
}

defCloseBtn?.addEventListener('click', (e) => {
  e.preventDefault();
  e.stopPropagation();
  closeDefPanel();
});

defSaveBtn?.addEventListener('click', async (e) => {
  e.preventDefault();
  e.stopPropagation();

  if (!currentDefConcept) return;

  const prev = defSaveBtn.textContent;
  defSaveBtn.disabled = true;
  defSaveBtn.textContent = 'Saving‚Ä¶';

  try {
    await setDefinition(
      currentDefConcept,
      defBox?.textContent || '',
      whyBox?.textContent || ''
    );
    refreshConceptDefBadges(document.getElementById('chat'));

    defSaveBtn.textContent = 'Saved ‚úì';
    setTimeout(() => {
      closeDefPanel();
      defSaveBtn.textContent = prev;
    }, 450);

  } catch (err) {
    console.error(err);
    defSaveBtn.textContent = 'Error';
    setTimeout(() => (defSaveBtn.textContent = prev), 900);
  } finally {
    defSaveBtn.disabled = false;
  }
});

defDeleteBtn?.addEventListener('click', async (e) => {
  e.preventDefault();
  e.stopPropagation();

  if (!currentDefConcept) return;

  const prev = defDeleteBtn.textContent;
  defDeleteBtn.disabled = true;

  try {
    await deleteDefinition(currentDefConcept);
    if (defBox) defBox.textContent = '';
    if (whyBox) whyBox.textContent = '';
    refreshConceptDefBadges(document.getElementById('chat'));
    setTimeout(() => closeDefPanel(), 150);

  } catch (err) {
    console.error(err);
    defDeleteBtn.textContent = 'Error';
    setTimeout(() => (defDeleteBtn.textContent = prev), 900);
  } finally {
    defDeleteBtn.textContent = prev;
    defDeleteBtn.disabled = false;
  }
});

defSearchBtn?.addEventListener('click', (e) => {
  e.preventDefault();
  e.stopPropagation();

  if (!currentDefConcept) return;
  userInput.value = `"${currentDefConcept}"`;
  userInput.focus();
  runLiveSearch(userInput.value.trim(), true);
});

/* =========================
   MERGE: unify [[old]] -> [[new]] across notes + defs
   - Only replaces exact concept pills [[...]] (not plain text)
   - Case-insensitive match of the inner concept text
   - Preserves the NEW concept casing exactly as you type it
========================= */
function escapeRegExp(s) {
  return (s || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

function buildConceptPillRegex(oldConcept) {
  // matches [[  oldConcept  ]] with flexible whitespace
  // and case-insensitive on the concept text
  const inner = escapeRegExp((oldConcept || '').trim());
  return new RegExp(`\\[\\[\\s*${inner}\\s*\\]\\]`, 'gi');
}

async function mergeConceptEverywhere(oldConcept, newConcept) {
  const oldTrim = (oldConcept || '').trim();
  const newTrim = (newConcept || '').trim();
  if (!oldTrim || !newTrim) return { changed: 0 };

  const oldKey = defKeyForConcept(oldTrim);
  const newKey = defKeyForConcept(newTrim);
  if (!oldKey || !newKey) return { changed: 0 };

  if (oldKey === newKey) {
    // same normalized key ‚Äî no need to rewrite defs doc; but we can still unify casing in notes
  }

  await ensureSignedIn();

  // 1) Update notes in batches (500 limit per batch write)
  const rx = buildConceptPillRegex(oldTrim);
  const repl = `[[${newTrim}]]`;

  const changedDocs = [];
  for (const n of notesCache) {
    const html = (n.content || '');
    if (!rx.test(html)) continue;
    const nextHtml = html.replace(rx, repl);
    if (nextHtml !== html) changedDocs.push({ id: n.id, content: nextHtml });
  }

  let changed = 0;
  for (let i = 0; i < changedDocs.length; i += 400) {
    const chunk = changedDocs.slice(i, i + 400);
    const batch = db.batch();
    chunk.forEach(doc => {
      batch.update(db.collection('notes').doc(doc.id), { content: doc.content });
    });
    await batch.commit();
    changed += chunk.length;
  }

  // 2) Merge definition docs (prefer keeping existing NEW text if it already exists)
  // pull latest from cache first (listener may lag a moment; we still handle safely)
  const oldDef = defsCache?.[oldKey] || null;
  const newDef = defsCache?.[newKey] || null;

  const oldVal = (oldDef?.value || '').trim();
  const oldWhy = (oldDef?.why || '').trim();

  const newVal = (newDef?.value || '').trim();
  const newWhy = (newDef?.why || '').trim();

  // If the target has no definition/why, carry over from old.
  // If it already has content, keep it (don‚Äôt overwrite).
  if ((oldVal || oldWhy) && (!newVal || !newWhy)) {
    await db.collection('concept_defs').doc(newKey).set({
      concept: newTrim,
      value: newVal || oldVal,
      why: newWhy || oldWhy,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  } else {
    // still make sure the pretty concept name is stored
    await db.collection('concept_defs').doc(newKey).set({
      concept: newTrim,
      updatedAt: firebase.firestore.FieldValue.serverTimestamp()
    }, { merge: true });
  }

  // Delete the old doc if it‚Äôs a different key
  if (oldKey !== newKey) {
    try { await db.collection('concept_defs').doc(oldKey).delete(); } catch {}
  }

  return { changed };
}

defMergeBtn?.addEventListener('click', async (e) => {
  e.preventDefault();
  e.stopPropagation();

  if (!currentDefConcept) return;

  const from = currentDefConcept;
  const to = prompt(`Merge concept:\n\nFrom: ${from}\n\nInto (new name):`, from);
  if (!to) return;

  const toTrim = to.trim();
  if (!toTrim) return;

  // quick guard: avoid accidental same target (case-insensitive)
  if (normalizeText(from) === normalizeText(toTrim)) {
    // still allow casing unify in notes
    // proceed anyway
  }

  const prev = defMergeBtn.textContent;
  defMergeBtn.disabled = true;
  defMergeBtn.textContent = 'Merging‚Ä¶';

  try {
    const res = await mergeConceptEverywhere(from, toTrim);

    // refresh UI
    closeDefPanel();
    refreshConceptDefBadges(document.getElementById('chat'));

    // re-run current search so results + badges update immediately
    const q = (userInput.value || '').trim();
    if (q) runLiveSearch(q, true);
    else renderWelcome();

    alert(`Merged ‚úì\nUpdated notes: ${res.changed}`);
  } catch (err) {
    console.error(err);
    alert('Merge failed: ' + (err?.message || err));
  } finally {
    defMergeBtn.disabled = false;
    defMergeBtn.textContent = prev;
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && defPanel?.style?.display === 'block') closeDefPanel();
}, true);

document.addEventListener('mousedown', (e) => {
  if (defPanel?.style?.display !== 'block') return;
  if (defPanel.contains(e.target)) return;
  closeDefPanel();
}, true);

/* =========================
   Concept linkify
========================= */
function conceptLinkifyHTML(html) {
  if (!html) return html;

  const wrap = document.createElement('div');
  wrap.innerHTML = html;

  const re = /\[\[([^\]\[]+?)\]\]/g;

  const walker = document.createTreeWalker(wrap, NodeFilter.SHOW_TEXT, null);
  const textNodes = [];
  while (walker.nextNode()) textNodes.push(walker.currentNode);

  textNodes.forEach(node => {
    const parent = node.parentElement;
    if (!parent) return;

    if (parent.closest('a, button')) return;

    const txt = node.nodeValue || '';
    if (!re.test(txt)) return;
    re.lastIndex = 0;

    const frag = document.createDocumentFragment();
    let last = 0;

    txt.replace(re, (m, inner, offset) => {
      frag.appendChild(document.createTextNode(txt.slice(last, offset)));

      const concept = (inner || '').trim();
      if (!concept) {
        frag.appendChild(document.createTextNode(m));
        last = offset + m.length;
        return m;
      }

      const normalized = normalizeText(concept);
      const count = conceptCountMap.get(normalized) || 0;

      const a = document.createElement('a');
      a.href = '#';
      a.className = 'conceptLink';
      a.dataset.concept = concept;

      const label = document.createElement('span');
      label.textContent = concept;
      a.appendChild(label);

      const def = (getDefinition(concept) || '').trim();
      if (def) {
        a.classList.add('hasDef');
        a.setAttribute('data-def', def);
      }

      if (count > 0) {
        const badge = document.createElement('span');
        badge.className = 'conceptCount';
        badge.textContent = String(count);
        a.appendChild(badge);
      }

      frag.appendChild(a);

      last = offset + m.length;
      return m;
    });

    frag.appendChild(document.createTextNode(txt.slice(last)));
    node.parentNode.replaceChild(frag, node);
  });

  return wrap.innerHTML;
}

/* =========================
   Render notes into ANY container
========================= */
function displayNotesInto(targetEl, notes) {
  if (!notes.length) {
    const msg = document.createElement('div');
    msg.className = 'message bot';
    const bubble = document.createElement('div');
    bubble.className = 'chatBubble';
    bubble.textContent = 'ü§ñ ‚ùå No matching notes found.';
    msg.appendChild(bubble);
    targetEl.appendChild(msg);
    return;
  }

  for (const note of notes) {
    const div = document.createElement('div');
    div.className = 'message bot';

    const bubble = document.createElement('div');
    bubble.className = 'chatBubble';
    bubble.innerHTML = 'ü§ñ ' + conceptLinkifyHTML(stripLegacyTableControls(note.content || ''));
    setTableCellsEditable(bubble, false);
    div.appendChild(bubble);

    const btns = document.createElement('div');
    btns.style.textAlign = 'center';
    btns.style.marginTop = '6px';

    const editBtn = document.createElement('button');
    editBtn.type = 'button';
    editBtn.textContent = '‚úèÔ∏è';

    const delBtn = document.createElement('button');
    delBtn.type = 'button';
    delBtn.textContent = 'üóëÔ∏è';

    [editBtn, delBtn].forEach(btn => Object.assign(btn.style, {
      background: 'none',
      border: 'none',
      color: '#666',
      fontSize: '16px',
      cursor: 'pointer',
      marginRight: '12px'
    }));

    btns.append(editBtn, delBtn);
    div.appendChild(btns);
    targetEl.appendChild(div);

    editBtn.onclick = () => {
      isEditingNote = true;

      bubble.style.display = 'none';
      btns.style.display = 'none';

      const editable = document.createElement('div');
      editable.contentEditable = true;
      editable.innerHTML = (note.content || '').replace(/<mark class="underlineMatch">([\s\S]*?)<\/mark>/gi, '$1');
      setTableCellsEditable(editable, true);
      editable.className = 'editableNote';
      activeEditable = editable;

      editable.addEventListener('focus', () => activeEditable = editable);
      editable.addEventListener('input', saveCaret);
      editable.addEventListener('mouseup', saveCaret);
      editable.addEventListener('keyup', saveCaret);

      const saveBtn = document.createElement('button');
      saveBtn.type = 'button';

      const cancelBtn = document.createElement('button');
      cancelBtn.type = 'button';

      saveBtn.textContent = 'üíæ';
      cancelBtn.textContent = '‚ùå';

      [saveBtn, cancelBtn].forEach(btn => Object.assign(btn.style, {
        background: 'none',
        border: 'none',
        color: '#666',
        fontSize: '16px',
        cursor: 'pointer',
        marginRight: '12px'
      }));

      const imgBtnWrap = makeInlineImagePickerButton((dataUrl) => {
        activeEditable = editable;
        editable.focus();
        insertImageAtCaret(dataUrl);
      });

      const emojiBtn = document.createElement('button');
      emojiBtn.type = 'button';
      emojiBtn.textContent = 'üåü';

      Object.assign(emojiBtn.style, {
        background: 'none',
        border: 'none',
        color: '#666',
        fontSize: '16px',
        cursor: 'pointer',
        marginRight: '12px'
      });

      emojiBtn.addEventListener('mousedown', (e) => {
        e.preventDefault();
        e.stopPropagation();

        activeEditable = editable;
        editable.focus({ preventScroll: true });
        saveCaret();

        showEmojiPanelNearButton(emojiBtn, (picked) => {
          activeEditable = editable;
          editable.focus({ preventScroll: true });
          restoreCaret();
          insertEmojiAtCaret(picked);
        });
      });

      const actions = document.createElement('div');
      actions.style.textAlign = 'center';
      actions.style.marginTop = '6px';

      actions.append(imgBtnWrap, emojiBtn, saveBtn, cancelBtn);

      actions.addEventListener('mousedown', () => {
        activeEditable = editable;
        editable.focus({ preventScroll: true });
        saveCaret();
      }, true);

      setTimeout(() => {
        activeEditable = editable;
        editable.focus({ preventScroll: true });
        placeCaretAtEnd(editable);
        saveCaret();
      }, 0);

      div.append(editable, actions);

      const tags = extractTagsFromHtml(stripLegacyTableControls(note.content || ''));
      if (tags.length) {
        const row = document.createElement('div');
        row.className = 'tagRow';

        tags.forEach(tag => {
          const chip = document.createElement('span');
          chip.className = 'tagChip';
          chip.textContent = '#' + tag;

          chip.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();

            const token = '#' + tag;
            const current = (userInput.value || '').trim();

            const next = current
              ? (current.includes(token) ? current : (current + ' ' + token))
              : token;

            userInput.value = next.trim();
            userInput.focus();
            runLiveSearch(userInput.value.trim(), true);
          });

          row.appendChild(chip);
        });

        div.appendChild(row);
      }

      cancelBtn.onclick = () => {
        isEditingNote = false;
        hideEmojiPanel();
        editable.remove();
        actions.remove();
        bubble.style.display = '';
        btns.style.display = '';
      };

      saveBtn.onclick = async () => {
        const updated = deLinkifyConceptAnchors(editable.innerHTML.trim());
        if (!updated) return alert('Cannot save empty note');

        try {
          await ensureSignedIn();
          await db.collection('notes').doc(note.id).update({ content: updated });
          note.content = updated;

          bubble.innerHTML = 'ü§ñ ' + conceptLinkifyHTML(stripLegacyTableControls(updated));
          hideEmojiPanel();
          editable.remove();
          actions.remove();
          bubble.style.display = '';
          btns.style.display = '';

          isEditingNote = false;
          refreshConceptDefBadges(liveResults);
        } catch (e) {
          alert('Error saving note: ' + e.message);
        }
      };
    };

    delBtn.onclick = async () => {
      if (!confirm('Delete this note?')) return;
      try {
        await ensureSignedIn();
        await db.collection('notes').doc(note.id).delete();
        div.remove();

        const q = userInput.value.trim();
        if (q) runLiveSearch(q, true);
        else renderLiveResults(notesCache.slice(0, 30), 'Latest notes');

      } catch (e) {
        alert('Failed to delete: ' + e.message);
      }
    };
  }
}

/* =========================
   Hashtag suggestions (your existing)
========================= */
const tagSuggest = document.getElementById('tagSuggest');
let suggestOpen = false;
let suggestItems = [];
let suggestIndex = -1;

function buildTagIndexFromCache() {
  const map = new Map();
  for (const n of notesCache) {
    const cleaned = stripLegacyTableControls(n.content || '');
    const tags = extractTagsFromHtml(cleaned);
    for (const t of tags) map.set(t, (map.get(t) || 0) + 1);
  }
  return [...map.entries()]
    .sort((a, b) => (b[1] - a[1]) || a[0].localeCompare(b[0]))
    .map(([tag, count]) => ({ tag, count }));
}

function getCurrentHashToken(inputValue, caretPos) {
  const left = inputValue.slice(0, caretPos);
  const m = left.match(/(^|\s)#([a-zA-Z0-9_-]*)$/);
  if (!m) return null;
  return {
    prefix: m[1] || '',
    typed: (m[2] || ''),
    start: left.length - m[2].length,
  };
}

function positionSuggestUnderInput() {
  const r = userInput.getBoundingClientRect();
  const pad = 10;

  const w = Math.max(220, Math.min(r.width, window.innerWidth - 20));
  tagSuggest.style.width = w + 'px';

  let left = r.left + (r.width - w) / 2;
  left = Math.max(10, Math.min(left, window.innerWidth - w - 10));
  tagSuggest.style.left = left + 'px';

  const h = tagSuggest.getBoundingClientRect().height || 180;

  let top = r.top - h - pad;
  if (top < 10) top = r.bottom + pad;
  top = Math.max(10, Math.min(top, window.innerHeight - h - 10));
  tagSuggest.style.top = top + 'px';
}

function closeSuggest() {
  suggestOpen = false;
  suggestItems = [];
  suggestIndex = -1;
  tagSuggest.style.display = 'none';
  tagSuggest.setAttribute('aria-hidden', 'true');
  tagSuggest.innerHTML = '';
}

function openSuggest(items) {
  suggestOpen = true;
  suggestItems = items;
  suggestIndex = 0;

  tagSuggest.innerHTML = '';
  items.forEach((it, idx) => {
    const row = document.createElement('div');
    row.className = 'item' + (idx === suggestIndex ? ' active' : '');
    row.innerHTML = `<span>#${it.tag}</span><span class="count">${it.count}</span>`;

    row.addEventListener('mousedown', (e) => {
      e.preventDefault();
      applySuggestion(it.tag);
    });

    tagSuggest.appendChild(row);
  });

  tagSuggest.style.display = 'block';
  tagSuggest.setAttribute('aria-hidden', 'false');
  requestAnimationFrame(positionSuggestUnderInput);
}

function renderSuggestActive() {
  const rows = tagSuggest.querySelectorAll('.item');
  rows.forEach((r, i) => r.classList.toggle('active', i === suggestIndex));
}

function applySuggestion(tag) {
  const caret = userInput.selectionStart ?? (userInput.value || '').length;
  const token = getCurrentHashToken(userInput.value, caret);
  if (!token) return closeSuggest();

  const before = userInput.value.slice(0, caret).replace(/(^|\s)#([a-zA-Z0-9_-]*)$/, `$1#${tag} `);
  const after = userInput.value.slice(caret);

  userInput.value = before + after;

  const newCaret = before.length;
  userInput.setSelectionRange(newCaret, newCaret);

  closeSuggest();
  runLiveSearch(userInput.value.trim(), true);
}

document.addEventListener('mousedown', (e) => {
  if (!suggestOpen) return;
  if (tagSuggest.contains(e.target)) return;
  if (e.target === userInput) return;
  closeSuggest();
});

userInput.addEventListener('keydown', (e) => {
  if (!suggestOpen) return;

  if (e.key === 'ArrowDown') {
    e.preventDefault();
    suggestIndex = Math.min(suggestItems.length - 1, suggestIndex + 1);
    renderSuggestActive();
    return;
  }
  if (e.key === 'ArrowUp') {
    e.preventDefault();
    suggestIndex = Math.max(0, suggestIndex - 1);
    renderSuggestActive();
    return;
  }
  if (e.key === 'Enter') {
    e.preventDefault();
    const it = suggestItems[suggestIndex];
    if (it) applySuggestion(it.tag);
    return;
  }
  if (e.key === 'Escape') {
    closeSuggest();
    return;
  }
});

function updateTagSuggestions() {
  if (!isUnlocked) return closeSuggest();

  const val = userInput.value || '';
  const caret = userInput.selectionStart ?? val.length;
  const token = getCurrentHashToken(val, caret);

  if (!token) return closeSuggest();

  const typed = normalizeTag(token.typed);

  const index = tagIndexSorted;
  const filtered = typed
    ? index.filter(x => x.tag.startsWith(typed)).slice(0, 12)
    : index.slice(0, 12);

  if (!filtered.length) return closeSuggest();
  openSuggest(filtered);
}

userInput.addEventListener('input', () => {
  updateTagSuggestions();
});

window.addEventListener('resize', () => {
  if (suggestOpen) positionSuggestUnderInput();
});

/* =========================
   Concept click handling
========================= */
document.addEventListener('click', (e) => {
  const a = e.target.closest('a.conceptLink');
  if (!a) return;

  e.preventDefault();
  e.stopPropagation();

  let topic = (a.getAttribute('data-concept') || a.textContent || '').trim();
  topic = topic.replace(/^\[\[\s*/, '').replace(/\s*\]\]$/, '').trim();
  if (!topic) return;

  if (e.shiftKey) {
    openDefPanel(topic, e.clientX, e.clientY);
    return;
  }

  userInput.value = `"${topic}"`;
  userInput.focus();
  runLiveSearch(userInput.value.trim(), true);
}, true);

function setTableCellsEditable(root, editable) {
  if (!root) return;
  root.querySelectorAll('.cellBox').forEach(cell => {
    cell.contentEditable = editable ? 'true' : 'false';
    if (!editable) {
      cell.setAttribute('tabindex', '-1');
      cell.style.caretColor = 'transparent';
    } else {
      cell.removeAttribute('tabindex');
      cell.style.caretColor = '';
    }
  });
}

/* =========================
   Live search runner
========================= */
function runLiveSearch(q, immediate = false) {
  if (!isUnlocked) return;

  const doIt = () => {
    lastLiveQuery = q;

    try {
      const notes = queryNotesSync('/find ' + q);
      renderLiveResults(notes, q);
    } catch (e) {
      console.error(e);
      showFatal('Search/render error: ' + (e?.message || e));
    }
  };

  if (immediate) return doIt();

  clearTimeout(liveTimer);
  liveTimer = setTimeout(doIt, 220);
}

userInput.addEventListener('input', () => {
  const q = userInput.value.trim();

  if (!q) {
    lastLiveQuery = '';
    if (isUnlocked) renderWelcome();
    else clearLiveResults();
    return;
  }

  runLiveSearch(q, false);
});

/* =========================
   Enter key behavior
========================= */
inputArea.addEventListener('submit', async (e) => {
  e.preventDefault();

  const raw = userInput.value.trim();
  if (!raw) return;

  if (/^\/ask\b/i.test(raw)) {
    const q = raw.replace(/^\/ask\s*/i, '').trim();
    if (!q) return;

    clearLiveResults();
    renderHeaderLine('Thinking‚Ä¶');

    try {
      const answer = await askAI(q);
      clearLiveResults();
      renderHeaderLine(answer);
    } catch (err) {
      clearLiveResults();
      renderHeaderLine('‚ö†Ô∏è Error getting response');
      console.error(err);
    }
    return;
  }

  runLiveSearch(raw, true);
});

/* =========================
   Formatting toolbar (your existing execCommand bindings)
========================= */
function runCmd(cmd, value = null) {
  if (!activeEditable) activeEditable = noteInput;

  activeEditable.focus({ preventScroll: true });
  restoreCaret();

  if (value === null) document.execCommand(cmd);
  else document.execCommand(cmd, false, value);

  saveCaret();
}

function bindToolbarBtn(id, cmd, value = null) {
  const btn = document.getElementById(id);
  if (!btn) return;

  btn.addEventListener('mousedown', (e) => {
    e.preventDefault();
    e.stopPropagation();
    runCmd(cmd, value);
  });
}

bindToolbarBtn('boldBtn', 'bold');
bindToolbarBtn('italicBtn', 'italic');
bindToolbarBtn('underlineBtn', 'underline');
bindToolbarBtn('highlightBtn', 'foreColor', '#5c6ac4');
bindToolbarBtn('redFontBtn', 'foreColor', 'red');
bindToolbarBtn('blueFontBtn', 'foreColor', 'blue');

/* =========================
   (Everything below here stays as-is in your file)
========================= */

/* UI toggles */
lockToggle.onclick = () => {
  lockSection.style.display = (lockSection.style.display === 'flex') ? 'none' : 'flex';
};

unlockBtn.onclick = () => {
  const code = (accessCodeInput.value || '').trim();
  if (code === ACCESS_CODE) {
    setUnlocked(true);
    lockSection.style.display = 'none';
  } else {
    lockInfo.textContent = "Wrong code";
    accessCodeInput.select();
  }
};

lockBtn.onclick = () => {
  setUnlocked(false);
  lockSection.style.display = 'none';
};

document.getElementById('formatToggle').onclick = () =>
  document.getElementById('formatToolbar').classList.toggle('visible');

function getActiveEditor() {
  const el = activeEditable;
  if (!el) return null;
  if (el === userInput) return null;
  if (!el.isContentEditable) return null;
  return el;
}

function wrapSelectionWithBrackets(mode = 'wrap') {
  const editor = getActiveEditor();
  if (!editor) return;

  editor.focus({ preventScroll: true });
  restoreCaret();

  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return;

  const range = sel.getRangeAt(0);
  if (!editor.contains(range.commonAncestorContainer)) return;

  const selectedText = sel.toString();
  if (!selectedText || !selectedText.trim()) return;

  const trimmed = selectedText.trim();
  const hasBrackets = /^\s*\[\[[\s\S]*\]\]\s*$/.test(selectedText);

  let replacement = '';
  if (mode === 'unwrap' || hasBrackets) {
    replacement = trimmed.replace(/^\[\[\s*/, '').replace(/\s*\]\]$/, '');
  } else {
    replacement = `[[${trimmed}]]`;
  }

  range.deleteContents();
  range.insertNode(document.createTextNode(replacement));

  range.collapse(false);
  sel.removeAllRanges();
  sel.addRange(range);

  saveCaret();
  refreshConceptDefBadges(document.getElementById('chat'));
}

// Ctrl+L = wrap, Shift+L = unwrap
document.addEventListener('keydown', (e) => {
  const t = e.target;
  if (t === userInput || t === accessCodeInput) return;

  const key = (e.key || '').toLowerCase();
  if (key !== 'l') return;

  if (e.ctrlKey || e.metaKey) {
    e.preventDefault();
    wrapSelectionWithBrackets('wrap');
    return;
  }

  if (e.shiftKey && !e.ctrlKey && !e.metaKey && !e.altKey) {
    e.preventDefault();
    wrapSelectionWithBrackets('unwrap');
    return;
  }
}, true);

updateUIForLockState();
</script>

</body>
</html>
