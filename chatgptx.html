<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Minimal Chat with Full Features</title>
<style>
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: 'Tahoma', sans-serif;
  color: #222;
  display: flex;
  flex-direction: column;
  overflow: hidden;

  /* Background image */
  background: url('2b.png') no-repeat center center fixed;
  background-size: cover;
  position: relative;
}

/* Glass overlay (must NOT block clicks) */
body::before {
  content: "";
  position: fixed;
  inset: 0;
  background: rgba(255, 255, 255, 0.7);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  z-index: 0;
  pointer-events: none;
}

#chat {
  flex-grow: 1;
  width: 100%;
  padding: 20px 5vw 160px 80px;
  overflow-y: auto;
  font-size: 12px;
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  box-sizing: border-box;
  border-radius: 12px;
  position: relative;
  z-index: 1;
}

/* Live results area */
#liveResults {
  position: relative;
  z-index: 2;
}

/* Message bubbles */
.message {
  margin-left: 7px;
  margin-bottom: 8px;
  line-height: 1.6;
  font-size: 12px;
  white-space: pre-wrap;
  word-wrap: break-word;
  word-break: break-word;
  display: flex;
  flex-direction: column;
  align-items: flex-start;
}

.message.user { align-items: flex-end; }

.message.bot {
  border-top: 1px solid rgba(0, 0, 0, 0.1);
  padding-top: 12px;
  margin-top: 12px;
  margin-left: 7px;
}

.message img {
  max-width: 100%;
  margin-top: 6px;
  border-radius: 8px;
}

.editableNote a,
.chatBubble a {
  word-break: break-word;
  overflow-wrap: anywhere;
  color: #1a0dab;
  text-decoration: underline;
}

.chatBubble {
  background: rgba(255, 255, 255, 0.3);
  border-radius: 12px;
  padding: 8px 12px;
  max-width: 70%;
  animation: fadeIn 0.3s ease;
  word-wrap: break-word;
  white-space: pre-wrap;
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
  color: #222;
}

.message.user .chatBubble {
  background: rgba(224, 193, 198, 0.25);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);
  align-self: flex-end;
}

.message.bot .chatBubble {
  background: rgba(255, 255, 255, 0.15);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  box-shadow: 0 0 12px 3px rgba(255, 255, 255, 0.8);
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.3);
  align-self: flex-start;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(6px); }
  to   { opacity: 1; transform: translateY(0); }
}

input[type="file"]::file-selector-button {
  background: rgba(255, 255, 255, 0.25);
  border: 1px solid rgba(255, 255, 255, 0.4);
  border-radius: 8px;
  padding: 6px 12px;
  color: #333;
  cursor: pointer;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.3);
  transition: box-shadow 0.3s ease;
}

input[type="file"]::file-selector-button:hover {
  background: rgba(255, 255, 255, 0.5);
  box-shadow: 0 0 20px 6px rgba(255, 255, 255, 0.7);
  color: #111;
}

/* Input Area */
#inputArea {
  position: fixed;
  bottom: 40px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  width: 90vw;
  max-width: 600px;
  gap: 10px;
  background: rgba(255, 255, 255, 0.25);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  padding: 12px 20px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(100, 100, 100, 0.1);
  z-index: 100;
  box-sizing: border-box;
}

#inputArea, #notePanel {
  background: rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  border: 1px solid rgba(255, 255, 255, 0.4);
}

#userInput {
  flex-grow: 1;
  font-size: 12px;
  padding: 10px 16px;
  border-radius: 12px;
  border: 1px solid #ddd;
  background: #f9f9f9;
  color: #3a3a3a;
  outline: none;
}

#userInput:focus {
  border-color: #999;
  box-shadow: 0 0 6px rgba(100, 100, 100, 0.4);
}

#sendBtn { display: none; }

/* Note Input */
#noteInput {
  min-height: 60px;
  max-height: 400px;
  overflow-y: auto;
  font-size: 13px;
  padding: 10px;
  border-radius: 12px;
  border: 1px solid rgba(255, 255, 255, 0.4);
  background: rgba(255, 255, 255, 0.15);
  color: #222;
  outline: none;
  white-space: pre-wrap;
  margin-top: 0 !important;
  padding-top: 0 !important;
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 0 10px 3px rgba(255, 255, 255, 0.3);
}

#noteInput:empty:before {
  content: attr(data-placeholder);
  color: #aaa;
  pointer-events: none;
  display: block;
}

/* Editable Notes */
.editableNote {
  background: none;
  color: #222;
  padding: 4px;
  border: none;
  font-size: 12px;
  font-family: 'Tahoma', sans-serif;
  white-space: pre-wrap;
  outline: none;
}



.resizableEmoji {
  font-size: 1.4em;
  font-weight: bold;
  display: inline-block;
}

/* Toolbar + Toggle */
#formatToggle {
  position: fixed;
  bottom: 40px;
  left: 20px;
  font-size: 20px;
  background: rgba(235, 235, 235, 0.25);
  border-radius: 50%;
  width: 44px;
  height: 44px;
  text-align: center;
  line-height: 44px;
  cursor: pointer;
  z-index: 105;
  box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.4);
  color: #444;
  transition: box-shadow 0.3s ease;
}

#formatToggle:hover {
  box-shadow: 0 0 15px rgba(255, 255, 255, 0.75);
  color: #222;
}

#formatToolbar {
  position: fixed;
  bottom: 80px;
  left: 20px;
  display: none;
  flex-direction: column;
  flex-wrap: nowrap;
  gap: 8px;
  align-items: center;
  justify-content: flex-start;
  background: rgba(255, 255, 255, 0.2);
  border: 1px solid rgba(255, 255, 255, 0.3);
  border-radius: 10px;
  padding: 5px 6px;
  z-index: 104;
  max-height: 500px;
  max-width: 90vw;
  overflow-x: auto;
  white-space: nowrap;
  -webkit-overflow-scrolling: touch;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  scrollbar-width: none;
  -ms-overflow-style: none;
  color: #444;
}

#formatToolbar.visible { display: flex; }

.format-btn {
  flex: 0 0 auto;
  background: none;
  border: none;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  color: #444;
  padding: 6px;
  border-radius: 6px;
  opacity: 0.7;
  transition: transform 0.2s ease, opacity 0.2s ease;
}

.format-btn:hover {
  transform: scale(1.2);
  opacity: 1;
  color: #222;
}

.emoji {
  background: none;
  color: #444;
  border: none;
  cursor: pointer;
  opacity: 0.7;
  font-size: 16px;
  transition: all 0.2s ease;
}

.emoji:hover {
  transform: scale(1.2);
  opacity: 1;
}

/* Note Panel */
#noteContainer {
  position: fixed;
  bottom: 40px;
  right: 20px;
  width: 50px;
  height: 50px;
  z-index: 103;
}

/* Click-to-select image + resize handles (JS adds .img-selected) */
.editableNote img,
#noteInput img {
  max-width: 100%;
  height: auto;
  display: block;
  margin: 10px 0;
  border-radius: 8px;
}

.img-selected {
  outline: 2px solid rgba(208, 160, 163, 0.9);
  outline-offset: 2px;
}

/* Tiny floating resize panel */
#imgSizePanel {
  position: fixed;
  z-index: 10060;
  display: none;
  gap: 8px;
  align-items: center;
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.45);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.18);
  font-size: 12px;
}

#imgSizePanel input[type="range"] { width: 120px; }
#imgSizePanel input[type="number"] { width: 70px; }
#imgSizePanel button {
  background: none;
  border: none;
  cursor: pointer;
  font-size: 14px;
  opacity: 0.8;
}
#imgSizePanel button:hover { opacity: 1; }
#addNoteToggle {
  position: fixed;
  width: 50px;
  height: 50px;
  font-size: 28px;
  border-radius: 50%;
  background: rgba(208, 160, 163, 0.3);
  color: #333;
  border: 1px solid rgba(255, 255, 255, 0.4);
  cursor: pointer;
  box-shadow: 0 0 12px rgba(208, 160, 163, 0.5);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  transition: box-shadow 0.3s ease;
}

#addNoteToggle:hover {
  box-shadow: 0 0 20px rgba(208, 160, 163, 0.8);
  color: #222;
}

/* =========================
   Minimal Table Style (FIXED)
========================= */

.cellBox {
  display: block;
  width: 100%;
  min-height: 24px;
  padding: 6px 8px;
  box-sizing: border-box;

  outline: none;
  white-space: pre-wrap;
  word-break: break-word;

  overflow: hidden;      /* hide scrollbars normally */
  resize: none;          /* no resize handle by default */
  background: transparent;
  transition: background 0.15s ease;
}

/* Show resize ONLY when hovering */
.editable-table td:hover .cellBox,
.editable-table th:hover .cellBox {
  resize: both;
  overflow: auto;        /* enable scroll only when resizing */
}

.editable-table {
  border-collapse: collapse;
  border: 1px solid rgba(0,0,0,0.15);
}

.editable-table th,
.editable-table td {
  border: 1px solid rgba(0,0,0,0.10);
  padding: 0;
  background: transparent;
  vertical-align: top;   /* fixes middle vs left issue */
  text-align: left;
}

.editable-table th .cellBox {
  font-weight: 600;
}

.cellBox {
  display: block;
  width: 100%;
  min-height: 24px;
  padding: 6px 8px;
  box-sizing: border-box;
  outline: none;
  white-space: pre-wrap;
  word-break: break-word;
  overflow: hidden;
  resize: none;
  background: transparent;
}

/* Floating table controls */


#notePanel {
  position: absolute;
  bottom: 60px;
  right: 0;
  width: 300px;
  background: rgba(254, 254, 254, 0.25);
  color: #222;
  border-radius: 12px;
  padding: 16px;
  display: none;
  flex-direction: column;
  gap: 12px;
  box-shadow:
    0 0 6px 1px rgba(220, 230, 255, 0.2),
    0 0 25px 8px rgba(204, 153, 255, 0.2);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  border: 1px solid rgba(255, 255, 255, 0.5);
  z-index: 104;
  transition: none;
}

#addNoteBtn {
  background: rgba(236, 235, 232, 0.25);
  color: #3a3a3a;
  border: 1px solid rgba(255, 255, 255, 0.4);
  padding: 10px;
  border-radius: 8px;
  cursor: pointer;
  backdrop-filter: blur(8px);
  -webkit-backdrop-filter: blur(8px);
  box-shadow: 0 0 10px rgba(236, 235, 232, 0.4);
  transition: box-shadow 0.3s ease;
}

#addNoteBtn:hover {
  box-shadow: 0 0 16px rgba(236, 235, 232, 0.7);
  color: #222;
}

/* search highlight color */
.underlineMatch{
  background: rgba(208, 160, 163, 0.25); /* <-- change this */
  color: inherit;
  border-bottom: 1px dotted rgba(0,0,0,0.35);
  padding: 0 2px;
  border-radius: 4px;
}

/* if the browser still applies <mark> defaults */
mark.underlineMatch{
  background: rgba(208, 160, 163, 0.25);
}

/* Floating emoji button + picker */
#floatingEmojiBtn {
  position: fixed;
  display: none;
  z-index: 10050;
  width: 34px;
  height: 34px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.35);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  box-shadow: 0 6px 18px rgba(0,0,0,0.15);
  cursor: pointer;
  user-select: none;
  align-items: center;
  justify-content: center;
  font-size: 18px;
  line-height: 1;
}

#floatingEmojiBtn:hover {
  transform: scale(1.06);
}

#floatingEmojiPanel {
  position: fixed;
  display: none;
  z-index: 10051;
  padding: 8px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.55);
  background: rgba(255,255,255,0.40);
  backdrop-filter: blur(14px);
  -webkit-backdrop-filter: blur(14px);
  box-shadow: 0 10px 30px rgba(0,0,0,0.18);
}

#floatingEmojiPanel .pick {
  width: 30px;
  height: 30px;
  border-radius: 10px;
  border: none;
  background: transparent;
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  opacity: 0.85;
}

#floatingEmojiPanel .pick:hover {
  opacity: 1;
  transform: scale(1.12);
}

/* Fullscreen image zoom overlay */
#imgZoomOverlay {
  position: fixed;
  inset: 0;
  z-index: 10080;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,0.65);
  backdrop-filter: blur(2px);
  -webkit-backdrop-filter: blur(2px);
}

#imgZoomStage {
  width: 92vw;
  height: 92vh;
  overflow: hidden;
  position: relative;
  cursor: grab;
}

#imgZoomStage:active { cursor: grabbing; }

#imgZoomImg {
  position: absolute;
  left: 50%;
  top: 50%;
  transform-origin: center center;
  will-change: transform;
  user-select: none;
  -webkit-user-drag: none;
  max-width: none;
  max-height: none;
  border-radius: 10px;
  box-shadow: 0 12px 40px rgba(0,0,0,0.35);
}

#imgZoomControls {
  position: fixed;
  top: 14px;
  left: 14px;
  z-index: 10081;
  display: none;
  gap: 8px;
  align-items: center;
  padding: 8px 10px;
  border-radius: 12px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(255,255,255,0.18);
  backdrop-filter: blur(12px);
  -webkit-backdrop-filter: blur(12px);
  color: #fff;
  font-size: 12px;
}

#imgZoomControls button {
  background: rgba(255,255,255,0.15);
  border: 1px solid rgba(255,255,255,0.25);
  color: #fff;
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
}

#imgZoomControls button:hover { background: rgba(255,255,255,0.25); }
/* Lock UI */
#lockToggle {
  position: fixed;
  top: 12px;
  right: 12px;
  background: #ecebe8;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  font-size: 15px;
  text-align: center;
  line-height: 40px;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
  z-index: 200;
}

#lockSection {
  position: fixed;
  top: 60px;
  right: 12px;
  display: none;
  flex-direction: column;
  align-items: flex-end;
  background: rgba(255, 255, 255, 0.95);
  padding: 10px 12px;
  border-radius: 12px;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.15);
  gap: 8px;
  z-index: 199;
}

#lockSection input {
  background: #ecebe8;
  color: #333;
  border: 1px solid #ccc;
  padding: 6px 10px;
  border-radius: 6px;
  font-size: 10px;
}

#lockSection button {
  background: #d0a0a3;
  color: black;
  border: none;
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 10px;
}

#lockBtn:hover, #unlockBtn:hover { background: #ecebe8; }
#lockInfo { color: #555; font-weight: 100; }

/* Responsive */
@media (max-width: 600px) {
  #chat { padding: 12px 4vw 160px 4vw; }
  #inputArea { width: 70vw; bottom: 30px; }
  #notePanel { width: 90vw; right: 5vw; }
  #lockSection { top: 10px; right: 10px; gap: 6px; } /* fixed from #authSection */
}
</style>


</head>

<body>

<div id="lockToggle" title="Enter access code">ðŸ”’</div>

<div id="lockSection">
  <input type="password" id="accessCode" placeholder="Access code" autocomplete="off" />
  <button id="unlockBtn">Unlock</button>
  <button id="lockBtn" style="display:none;" title="Lock">ðŸ”’</button>
  <div id="lockInfo">Locked</div>
</div>


<div id="formatToggle">ðŸ“‹</div>

<div id="formatToolbar">
  <button class="format-btn" id="boldBtn"><b>B</b></button>
  <button class="format-btn" id="italicBtn"><i>I</i></button>
  <button class="format-btn" id="underlineBtn"><u>U</u></button>
  <button class="format-btn" id="highlightBtn">ðŸŸª</button>
  <button class="format-btn" id="redFontBtn">ðŸŸ¥</button>
  <button class="format-btn" id="blueFontBtn">ðŸŸ¦</button>

  <button class="format-btn" id="increaseFontBtn" title="Increase Font Size">ðŸ”ºA</button>
  <button class="format-btn" id="decreaseFontBtn" title="Decrease Font Size">ðŸ”»A</button>

  <button class="format-btn" id="insertTableBtn">ðŸ“Š</button>
  <button class="format-btn" id="addRowBtn" title="Add Table Row">+R</button>
  <button class="format-btn" id="deleteRowBtn" title="Delete Table Row">-R</button>
  <button class="format-btn" id="addColBtn" title="Add Table Column">+C</button>
  <button class="format-btn" id="deleteColBtn" title="Delete Table Column">-C</button>

  <button class="format-btn" id="resetColorBtn">â†º</button>

  
</div>

<!-- Container for add button and note panel -->
<div id="noteContainer">
  <button id="addNoteToggle" title="Add Note">ï¼‹</button>
  <div id="notePanel" style="display:none; flex-direction: column;">
    <div id="noteInput" contenteditable="true" data-placeholder="Type or paste your note here..."></div>
    <button id="addNoteBtn">Add Note</button>
  </div>
</div>

<!-- Chat area + Live Results go inside this -->
<div id="chat">
  <div id="liveResults"></div>
</div>

<form id="inputArea">
  <input type="text" id="userInput" placeholder="Type to search notesâ€¦ (use /ask to ask AI)" autocomplete="off" required />
  <button type="submit" id="sendBtn">Send</button>
</form>

<div id="floatingEmojiBtn" title="Insert emoji">ðŸ“Œ</div>
<div id="floatingEmojiPanel" aria-hidden="true"></div>

<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-firestore-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-storage-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.1/firebase-auth-compat.js"></script>

<script type="module">
/* =========================
   Firebase init
========================= */
const firebaseConfig = {
  apiKey: "AIzaSyDtv3x9PAMzZUW6yVuUSLgLzA0ejcDidF4",
  authDomain: "notes-chat-c5ff3.firebaseapp.com",
  projectId: "notes-chat-c5ff3",
  storageBucket: "notes-chat-c5ff3.appspot.com",
  messagingSenderId: "597780727252",
  appId: "1:597780727252:web:8407eb4096dbe301d74241",
  measurementId: "G-YQD63H7L5T"
};

firebase.initializeApp(firebaseConfig);

const db = firebase.firestore();
const storage = firebase.storage();
const auth = firebase.auth();
auth.setPersistence(firebase.auth.Auth.Persistence.LOCAL);

/* =========================
   DOM refs
========================= */
const chat = document.getElementById('chat');
const liveResults = document.getElementById('liveResults');

const noteInput = document.getElementById('noteInput');
const addNoteBtn = document.getElementById('addNoteBtn');
const addNoteToggle = document.getElementById('addNoteToggle');
const notePanel = document.getElementById('notePanel');

const lockToggle = document.getElementById('lockToggle');
const lockSection = document.getElementById('lockSection');
const accessCodeInput = document.getElementById('accessCode');
const unlockBtn = document.getElementById('unlockBtn');
const lockBtn = document.getElementById('lockBtn');
const lockInfo = document.getElementById('lockInfo');

const inputArea = document.getElementById('inputArea');
const userInput = document.getElementById('userInput');

/* =========================
   Live search cache state
========================= */
let notesCache = [];
let unsubscribeNotes = null;
let liveTimer = null;
let lastLiveQuery = '';

function clearLiveResults() {
  liveResults.innerHTML = '';
}

function renderHeaderLine(text) {
  const header = document.createElement('div');
  header.className = 'message bot';
  const bubble = document.createElement('div');
  bubble.className = 'chatBubble';
  bubble.textContent = 'ðŸ¤– ' + text;
  header.appendChild(bubble);
  liveResults.appendChild(header);
}

function renderWelcome() {
  clearLiveResults();
  renderHeaderLine('âœ… Welcome. Type in the search box to find notes.');
}

function renderLiveResults(notes, queryLabel) {
  clearLiveResults();
  renderHeaderLine(`Results for: ${queryLabel}`);

  const container = document.createElement('div');
  liveResults.appendChild(container);

  displayNotesInto(container, notes);
  chat.scrollTo({ top: chat.scrollHeight, behavior: 'smooth' });
}

/* =========================
   Hard error banner (shows real JS errors)
========================= */
function showFatal(msg) {
  clearLiveResults();
  renderHeaderLine('âŒ ' + msg);
}

window.addEventListener('error', (e) => {
  showFatal(e.message || 'Script error');
});

window.addEventListener('unhandledrejection', (e) => {
  showFatal((e.reason && (e.reason.message || String(e.reason))) || 'Unhandled promise rejection');
});

/* =========================
   Editor state
========================= */
let activeEditable = noteInput;
noteInput.addEventListener('focus', () => activeEditable = noteInput);

/* =========================
   Image upload inside notePanel (preview only)
========================= */
const imageUpload = document.createElement('input');
imageUpload.type = 'file';
imageUpload.accept = 'image/*';
imageUpload.id = 'imageUpload';
imageUpload.style.marginTop = '10px';
notePanel.insertBefore(imageUpload, addNoteBtn);

imageUpload.addEventListener('change', function () {
  const file = this.files?.[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = e => {
    activeEditable.innerHTML += `<br><img src="${e.target.result}" style="width:100%; height:auto; border-radius:8px;" /><br>`;
    placeCaretAtEnd(activeEditable);
    saveCaret();
  };
  reader.readAsDataURL(file);
});

/* =========================
   Simple access code gate
========================= */
const ACCESS_CODE = "oatee";
let isUnlocked = (localStorage.getItem('notes_unlocked') === '1');

function setUnlocked(state) {
  isUnlocked = state;
  localStorage.setItem('notes_unlocked', state ? '1' : '0');
  updateUIForLockState();
}

/* =========================
   Image resize UI (EDITING ONLY)
   - works in #noteInput and .editableNote
========================= */
let selectedImg = null;

const imgSizePanel = document.createElement('div');
imgSizePanel.id = 'imgSizePanel';
imgSizePanel.innerHTML = `
  <span style="opacity:.8">Size</span>
  <input id="imgSizeRange" type="range" min="10" max="150" value="100" />
  <span id="imgSizePct" style="width:38px; text-align:right;">100%</span>
  <span style="opacity:.8">W</span>
  <input id="imgSizePx" type="number" min="20" step="10" />
  <button id="imgSizeReset" title="Reset">â†º</button>
  <button id="imgSizeClose" title="Close">âœ•</button>
`;
document.body.appendChild(imgSizePanel);

const imgSizeRange = imgSizePanel.querySelector('#imgSizeRange');
const imgSizePct = imgSizePanel.querySelector('#imgSizePct');
const imgSizePx = imgSizePanel.querySelector('#imgSizePx');
const imgSizeReset = imgSizePanel.querySelector('#imgSizeReset');
const imgSizeClose = imgSizePanel.querySelector('#imgSizeClose');

function isEditorImage(img) {
  if (!img || img.tagName !== 'IMG') return false;
  return !!(img.closest('.editableNote') || img.closest('#noteInput'));
}

function showImgPanelAt(img, x, y) {
  const pad = 10;
  imgSizePanel.style.display = 'flex';

  const wStyle = (img.style.width || '').trim();
  const pct = wStyle.endsWith('%') ? parseInt(wStyle, 10) : 100;

  imgSizeRange.value = String(Math.max(10, Math.min(150, pct)));
  imgSizePct.textContent = imgSizeRange.value + '%';

  imgSizePx.value = Math.round(img.getBoundingClientRect().width);

  const panelRect = imgSizePanel.getBoundingClientRect();
  let left = x + pad;
  let top = y + pad;

  if (left + panelRect.width > window.innerWidth - 6) left = window.innerWidth - panelRect.width - 6;
  if (top + panelRect.height > window.innerHeight - 6) top = window.innerHeight - panelRect.height - 6;

  imgSizePanel.style.left = Math.max(6, left) + 'px';
  imgSizePanel.style.top = Math.max(6, top) + 'px';
}

function selectImg(img, x, y) {
  if (selectedImg && selectedImg !== img) selectedImg.classList.remove('img-selected');
  selectedImg = img;
  selectedImg.classList.add('img-selected');
  showImgPanelAt(selectedImg, x, y);
}

function clearImgSelection() {
  if (selectedImg) selectedImg.classList.remove('img-selected');
  selectedImg = null;
  imgSizePanel.style.display = 'none';
}

imgSizeRange.addEventListener('input', () => {
  if (!selectedImg) return;
  const v = parseInt(imgSizeRange.value, 10) || 100;
  imgSizePct.textContent = v + '%';
  selectedImg.style.width = v + '%';
  selectedImg.style.height = 'auto';
  imgSizePx.value = Math.round(selectedImg.getBoundingClientRect().width);
});

imgSizePx.addEventListener('change', () => {
  if (!selectedImg) return;
  const px = parseInt(imgSizePx.value, 10);
  if (!px || px < 20) return;

  selectedImg.style.width = px + 'px';
  selectedImg.style.height = 'auto';

  const parentW = selectedImg.parentElement?.getBoundingClientRect?.().width || px;
  const pct = Math.round((px / parentW) * 100);
  const clamped = Math.max(10, Math.min(150, pct));
  imgSizeRange.value = String(clamped);
  imgSizePct.textContent = clamped + '%';
});

imgSizeReset.addEventListener('click', () => {
  if (!selectedImg) return;
  selectedImg.style.width = '100%';
  selectedImg.style.height = 'auto';
  imgSizeRange.value = '100';
  imgSizePct.textContent = '100%';
  imgSizePx.value = Math.round(selectedImg.getBoundingClientRect().width);
});

imgSizeClose.addEventListener('click', clearImgSelection);

document.addEventListener('click', (e) => {
  const t = e.target;

  // only for EDITING images
  if (t && t.tagName === 'IMG' && isEditorImage(t)) {
    e.preventDefault();
    e.stopPropagation();
    selectImg(t, e.clientX, e.clientY);
    return;
  }

  if (!imgSizePanel.contains(e.target)) clearImgSelection();
}, true);

// Escape closes resize panel (but don't fight zoom escape; zoom handles it too)
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') clearImgSelection();
}, true);

/* =========================
   Image zoom viewer (VIEW MODE ONLY)
   - click image inside .chatBubble
========================= */
const imgZoomOverlay = document.createElement('div');
imgZoomOverlay.id = 'imgZoomOverlay';
imgZoomOverlay.innerHTML = `
  <div id="imgZoomControls">
    <button type="button" id="zoomOutBtn">âˆ’</button>
    <button type="button" id="zoomInBtn">ï¼‹</button>
    <button type="button" id="zoomResetBtn">Reset</button>
    <button type="button" id="zoomCloseBtn">Close</button>
  </div>
  <div id="imgZoomStage">
    <img id="imgZoomImg" alt="" />
  </div>
`;
document.body.appendChild(imgZoomOverlay);

const imgZoomControls = imgZoomOverlay.querySelector('#imgZoomControls');
const imgZoomStage = imgZoomOverlay.querySelector('#imgZoomStage');
const imgZoomImg = imgZoomOverlay.querySelector('#imgZoomImg');

const zoomInBtn = imgZoomOverlay.querySelector('#zoomInBtn');
const zoomOutBtn = imgZoomOverlay.querySelector('#zoomOutBtn');
const zoomResetBtn = imgZoomOverlay.querySelector('#zoomResetBtn');
const zoomCloseBtn = imgZoomOverlay.querySelector('#zoomCloseBtn');

let zoomOpen = false;
let zScale = 1;
let zX = 0; // pan x from center
let zY = 0; // pan y from center
let isPanning = false;
let panStartX = 0;
let panStartY = 0;

function applyZoomTransform() {
  imgZoomImg.style.transform =
    `translate(-50%, -50%) translate(${zX}px, ${zY}px) scale(${zScale})`;
}

function fitZoomToStage() {
  const stageRect = imgZoomStage.getBoundingClientRect();
  const iw = imgZoomImg.naturalWidth || 1;
  const ih = imgZoomImg.naturalHeight || 1;

  const scaleX = (stageRect.width * 0.98) / iw;
  const scaleY = (stageRect.height * 0.98) / ih;
  zScale = Math.min(scaleX, scaleY);

  zX = 0;
  zY = 0;

  applyZoomTransform();
}

function zoomBy(factor, centerClientX, centerClientY) {
  const newScale = Math.max(0.1, Math.min(8, zScale * factor));
  if (newScale === zScale) return;

  const stageRect = imgZoomStage.getBoundingClientRect();
  const stageCX = stageRect.left + stageRect.width / 2;
  const stageCY = stageRect.top + stageRect.height / 2;

  const mx = (centerClientX ?? stageCX) - stageCX;
  const my = (centerClientY ?? stageCY) - stageCY;

  const px = (mx - zX) / zScale;
  const py = (my - zY) / zScale;

  zScale = newScale;

  zX = mx - px * zScale;
  zY = my - py * zScale;

  applyZoomTransform();
}

function openZoom(src) {
  zoomOpen = true;

  imgZoomImg.src = src;
  imgZoomOverlay.style.display = 'flex';
  imgZoomControls.style.display = 'flex';

  zScale = 1;
  zX = 0;
  zY = 0;

  imgZoomImg.onload = () => {
    // 2 frames helps ensure stage has layout
    requestAnimationFrame(() => requestAnimationFrame(fitZoomToStage));
  };

  requestAnimationFrame(applyZoomTransform);
}

function closeZoom() {
  zoomOpen = false;
  imgZoomOverlay.style.display = 'none';
  imgZoomControls.style.display = 'none';
  imgZoomImg.src = '';
}

zoomInBtn.addEventListener('click', () => zoomBy(1.2));
zoomOutBtn.addEventListener('click', () => zoomBy(1 / 1.2));
zoomResetBtn.addEventListener('click', () => fitZoomToStage());
zoomCloseBtn.addEventListener('click', () => closeZoom());

imgZoomOverlay.addEventListener('click', (e) => {
  if (e.target === imgZoomOverlay) closeZoom();
});

imgZoomStage.addEventListener('wheel', (e) => {
  if (!zoomOpen) return;
  e.preventDefault();
  const factor = e.deltaY < 0 ? 1.12 : 1 / 1.12;
  zoomBy(factor, e.clientX, e.clientY);
}, { passive: false });

imgZoomStage.addEventListener('mousedown', (e) => {
  if (!zoomOpen) return;
  isPanning = true;

  const stageRect = imgZoomStage.getBoundingClientRect();
  const stageCX = stageRect.left + stageRect.width / 2;
  const stageCY = stageRect.top + stageRect.height / 2;

  panStartX = (e.clientX - stageCX) - zX;
  panStartY = (e.clientY - stageCY) - zY;
});

window.addEventListener('mousemove', (e) => {
  if (!zoomOpen || !isPanning) return;

  const stageRect = imgZoomStage.getBoundingClientRect();
  const stageCX = stageRect.left + stageRect.width / 2;
  const stageCY = stageRect.top + stageRect.height / 2;

  zX = (e.clientX - stageCX) - panStartX;
  zY = (e.clientY - stageCY) - panStartY;

  applyZoomTransform();
});

window.addEventListener('mouseup', () => {
  isPanning = false;
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && zoomOpen) closeZoom();
}, true);

function isViewingNoteImage(img) {
  if (!img || img.tagName !== 'IMG') return false;
  const inBubble = !!img.closest('.chatBubble');
  const inEditor = !!(img.closest('.editableNote') || img.closest('#noteInput'));
  return inBubble && !inEditor;
}

document.addEventListener('click', (e) => {
  const t = e.target;
  if (t && t.tagName === 'IMG' && isViewingNoteImage(t)) {
    e.preventDefault();
    e.stopPropagation();
    openZoom(t.src);
  }
}, true);

/* =========================
   UI lock state
========================= */
function updateUIForLockState() {
  if (isUnlocked) {
    lockInfo.textContent = "Unlocked";
    lockToggle.textContent = "ðŸ”“";
    lockToggle.title = "Unlocked";

    unlockBtn.style.display = "none";
    lockBtn.style.display = "inline-block";
    accessCodeInput.style.display = "none";

    addNoteToggle.style.display = 'inline-block';
    notePanel.style.display = 'none';

    startNotesListener();

  } else {
    lockInfo.textContent = "Locked";
    lockToggle.textContent = "ðŸ”’";
    lockToggle.title = "Enter access code";

    unlockBtn.style.display = "inline-block";
    lockBtn.style.display = "none";
    accessCodeInput.style.display = "inline-block";
    accessCodeInput.value = "";

    addNoteToggle.style.display = 'none';
    notePanel.style.display = 'none';

    stopNotesListener();
  }
}

/* =========================
   Auth UI + realtime cache
========================= */
function startNotesListener() {
  if (!isUnlocked) return;
  if (unsubscribeNotes) unsubscribeNotes();

  unsubscribeNotes = db.collection('notes')
    .onSnapshot((snap) => {
      notesCache = snap.docs.map(d => ({ id: d.id, ...d.data() }));

      notesCache.sort((a, b) => {
        const ta = a.createdAt?.toMillis?.() || 0;
        const tb = b.createdAt?.toMillis?.() || 0;
        return tb - ta;
      });

      const q = userInput.value.trim();
      if (q) runLiveSearch(q, true);
      else renderWelcome();

    }, (err) => {
      console.error('Notes listener error:', err);
      showFatal('Firestore: ' + (err?.message || err));
    });
}

function stopNotesListener() {
  if (unsubscribeNotes) {
    unsubscribeNotes();
    unsubscribeNotes = null;
  }
  notesCache = [];
  clearLiveResults();
}

/* =========================
   Caret save/restore
========================= */
let savedRange = null;

function saveCaret() {
  const sel = window.getSelection();
  if (sel.rangeCount > 0 && activeEditable.contains(sel.anchorNode)) {
    savedRange = sel.getRangeAt(0).cloneRange();
  }
}

function restoreCaret() {
  if (!savedRange) return false;
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(savedRange);
  return true;
}

function placeCaretAtEnd(el) {
  el.focus();
  const range = document.createRange();
  range.selectNodeContents(el);
  range.collapse(false);
  const sel = window.getSelection();
  sel.removeAllRanges();
  sel.addRange(range);
  savedRange = range.cloneRange();
}

['keyup', 'mouseup', 'focus', 'input'].forEach(evt => {
  noteInput.addEventListener(evt, saveCaret);
});

/* =========================
   Notes panel toggle
========================= */
addNoteToggle.onclick = () => {
  notePanel.style.display = (notePanel.style.display === 'flex') ? 'none' : 'flex';
  activeEditable = noteInput;
  noteInput.focus();
};

/* =========================
   Linkify
========================= */
function linkify(html) {
  const div = document.createElement('div');
  div.innerHTML = html;

  const walker = document.createTreeWalker(div, NodeFilter.SHOW_TEXT, null);
  const urlRegex = /\bhttps?:\/\/[^\s<]+/gi;

  const textNodes = [];
  while (walker.nextNode()) textNodes.push(walker.currentNode);

  textNodes.forEach(node => {
    const text = node.nodeValue;
    if (!urlRegex.test(text)) return;

    const frag = document.createDocumentFragment();
    let lastIndex = 0;
    text.replace(urlRegex, (match, offset) => {
      frag.appendChild(document.createTextNode(text.slice(lastIndex, offset)));
      const a = document.createElement('a');
      a.href = match;
      a.target = '_blank';
      a.rel = 'noopener noreferrer';
      a.textContent = match;
      frag.appendChild(a);
      lastIndex = offset + match.length;
      return match;
    });
    frag.appendChild(document.createTextNode(text.slice(lastIndex)));

    node.parentNode.replaceChild(frag, node);
  });

  return div.innerHTML;
}

/* =========================
   Add note
========================= */
addNoteBtn.onclick = async () => {
  if (!isUnlocked) return alert('Locked.');

  const raw = noteInput.innerHTML.trim();
  const noteContent = linkify(raw);

  if (!noteContent || noteContent === '<br>') return alert('Note is required.');

  addNoteBtn.disabled = true;
  addNoteBtn.textContent = 'Adding...';

  try {
    await ensureSignedIn();
    await db.collection('notes').add({
      content: noteContent,
      createdAt: firebase.firestore.FieldValue.serverTimestamp()
    });

    noteInput.innerHTML = '';
    imageUpload.value = '';
    notePanel.style.display = 'none';

    const q = userInput.value.trim();
    if (q) runLiveSearch(q, true);
    else renderLiveResults(notesCache.slice(0, 30), 'Latest notes');

  } catch (e) {
    alert('Error: ' + e.message);
  } finally {
    addNoteBtn.disabled = false;
    addNoteBtn.textContent = 'Add Note';
  }
};

async function ensureSignedIn() {
  if (auth.currentUser) return auth.currentUser;

  await new Promise((resolve) => {
    const unsub = auth.onAuthStateChanged(() => {
      unsub();
      resolve();
    });
  });

  if (auth.currentUser) return auth.currentUser;

  try {
    await auth.signInAnonymously();
    console.log("Signed in uid:", auth.currentUser?.uid);
    return auth.currentUser;
  } catch (e) {
    console.error("Anonymous sign-in failed:", e);
    throw e;
  }
}

function stripLegacyTableControls(html) {
  if (!html) return '';
  return html
    .replace(/<button[^>]*class="table-control-toggle"[\s\S]*?<\/button>/gi, '')
    .replace(/<div[^>]*class="table-control-panel"[\s\S]*?<\/div>/gi, '')
    .replace(/<button[^>]*class="table-btn"[\s\S]*?<\/button>/gi, '');
}

/* =========================
   "AI" placeholder (only used if you type /ask ...)
========================= */
async function askAI(question) {
  await new Promise(res => setTimeout(res, 250));
  return `You asked:\n${question}`;
}

/* =========================
   Search helpers
========================= */
function normalizeText(s) {
  return (s || '')
    .toLowerCase()
    .normalize('NFKD')
    .replace(/[\u0300-\u036f]/g, '')
    .trim();
}

function htmlToText(html) {
  const div = document.createElement('div');
  div.innerHTML = html || '';
  return div.textContent || div.innerText || '';
}

function parseFindQuery(raw) {
  const s = raw.replace(/^\/find\s+/i, '').trim();

  const phrases = [];
  const quoteRegex = /"([^"]+)"/g;
  let m;
  while ((m = quoteRegex.exec(s)) !== null) {
    const p = m[1].trim();
    if (p) phrases.push(p);
  }

  const remainder = s.replace(quoteRegex, ' ').split(',')
    .map(t => t.trim())
    .filter(Boolean);

  const terms = [...phrases, ...remainder].filter(Boolean);

  return { raw: s, terms: terms.map(normalizeText).filter(Boolean) };
}

function scoreDoc(textNorm, termsNorm) {
  let score = 0;
  for (const t of termsNorm) {
    if (!t) continue;
    if (textNorm.startsWith(t)) score += 6;

    const wholeWord = new RegExp(`\\b${t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'i');
    if (wholeWord.test(textNorm)) score += 3;

    if (textNorm.includes(t)) score += 1;
  }
  return score;
}

function highlightHTML(html, termsNorm) {
  if (!termsNorm?.length) return html;

  const container = document.createElement('div');
  container.innerHTML = html;

  const walker = document.createTreeWalker(container, NodeFilter.SHOW_TEXT, null);
  const nodes = [];
  while (walker.nextNode()) nodes.push(walker.currentNode);

  const escaped = termsNorm
    .filter(Boolean)
    .sort((a, b) => b.length - a.length)
    .map(t => t.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));

  if (!escaped.length) return html;
  const regex = new RegExp(`(${escaped.join('|')})`, 'gi');

  nodes.forEach(node => {
    const text = node.nodeValue;
    if (!regex.test(text)) return;

    const span = document.createElement('span');
    span.innerHTML = text.replace(regex, `<mark class="underlineMatch">$1</mark>`);
    node.parentNode.replaceChild(span, node);
  });

  return container.innerHTML;
}

/* =========================
   Cache-based query (SYNC + stable)
========================= */
function queryNotesSync(rawQuery) {
  if (!isUnlocked) return [];

  const { terms } = parseFindQuery(rawQuery);
  if (!terms.length) return notesCache.slice(0, 30);

  const results = [];

  for (const data of notesCache) {
    const originalHtml = data.content || '';
    const cleanedHtml = stripLegacyTableControls(originalHtml);

    const textNorm = normalizeText(htmlToText(cleanedHtml));

    const ok = terms.every(t => {
      if (!t) return true;
      if (textNorm.includes(t)) return true;
      return textNorm.split(/\s+/).some(w => w.startsWith(t));
    });

    if (!ok) continue;

    results.push({
      id: data.id,
      createdAt: data.createdAt,
      content: highlightHTML(cleanedHtml, terms),
      score: scoreDoc(textNorm, terms)
    });
  }

  results.sort((a, b) => {
    const s = b.score - a.score;
    if (s !== 0) return s;
    const ta = a.createdAt?.toMillis?.() || 0;
    const tb = b.createdAt?.toMillis?.() || 0;
    return tb - ta;
  });

  return results.slice(0, 30);
}

/* =========================
   Render notes into ANY container
========================= */
function displayNotesInto(targetEl, notes) {
  if (!notes.length) {
    const msg = document.createElement('div');
    msg.className = 'message bot';
    const bubble = document.createElement('div');
    bubble.className = 'chatBubble';
    bubble.textContent = 'ðŸ¤– âŒ No matching notes found.';
    msg.appendChild(bubble);
    targetEl.appendChild(msg);
    return;
  }

  for (const note of notes) {
    const div = document.createElement('div');
    div.className = 'message bot';

    const bubble = document.createElement('div');
    bubble.className = 'chatBubble';
    bubble.innerHTML = 'ðŸ¤– ' + stripLegacyTableControls(note.content || '');
    div.appendChild(bubble);

    const btns = document.createElement('div');
    btns.style.textAlign = 'center';
    btns.style.marginTop = '6px';

    const editBtn = document.createElement('button');
    editBtn.textContent = 'âœï¸';
    const delBtn = document.createElement('button');
    delBtn.textContent = 'ðŸ—‘ï¸';

    [editBtn, delBtn].forEach(btn => Object.assign(btn.style, {
      background: 'none',
      border: 'none',
      color: '#666',
      fontSize: '16px',
      cursor: 'pointer',
      marginRight: '12px'
    }));

    btns.append(editBtn, delBtn);
    div.appendChild(btns);
    targetEl.appendChild(div);

    editBtn.onclick = () => {
      bubble.style.display = 'none';
      btns.style.display = 'none';

      const editable = document.createElement('div');
      editable.contentEditable = true;
      editable.innerHTML = (note.content || '').replace(/<mark class="underlineMatch">([\s\S]*?)<\/mark>/gi, '$1');
      editable.className = 'editableNote';
      activeEditable = editable;

      editable.addEventListener('focus', () => activeEditable = editable);
      editable.addEventListener('input', saveCaret);
      editable.addEventListener('mouseup', saveCaret);
      editable.addEventListener('keyup', saveCaret);

      const saveBtn = document.createElement('button');
      const cancelBtn = document.createElement('button');
      saveBtn.textContent = 'ðŸ’¾';
      cancelBtn.textContent = 'âŒ';

      [saveBtn, cancelBtn].forEach(btn => Object.assign(btn.style, {
        background: 'none',
        border: 'none',
        color: '#666',
        fontSize: '16px',
        cursor: 'pointer',
        marginRight: '12px'
      }));

      const actions = document.createElement('div');
      actions.style.textAlign = 'center';
      actions.style.marginTop = '6px';
      actions.append(saveBtn, cancelBtn);

      div.append(editable, actions);

      cancelBtn.onclick = () => {
        editable.remove();
        actions.remove();
        bubble.style.display = '';
        btns.style.display = '';
      };

      saveBtn.onclick = async () => {
        const updated = editable.innerHTML.trim();
        if (!updated) return alert('Cannot save empty note');

        try {
          await ensureSignedIn();
          await db.collection('notes').doc(note.id).update({ content: updated });
          note.content = updated;

          bubble.innerHTML = 'ðŸ¤– ' + updated;
          editable.remove();
          actions.remove();
          bubble.style.display = '';
          btns.style.display = '';

          const q = userInput.value.trim();
          if (q) runLiveSearch(q, true);
          else renderLiveResults(notesCache.slice(0, 30), 'Latest notes');

        } catch (e) {
          alert('Error saving note: ' + e.message);
        }
      };
    };

    delBtn.onclick = async () => {
      if (!confirm('Delete this note?')) return;
      try {
        await ensureSignedIn();
        await db.collection('notes').doc(note.id).delete();
        div.remove();

        const q = userInput.value.trim();
        if (q) runLiveSearch(q, true);
        else renderLiveResults(notesCache.slice(0, 30), 'Latest notes');

      } catch (e) {
        alert('Failed to delete: ' + e.message);
      }
    };
  }
}

/* =========================
   Live search runner (SYNC + stable)
========================= */
function runLiveSearch(q, immediate = false) {
  if (!isUnlocked) return;

  const doIt = () => {
    lastLiveQuery = q;

    try {
      const notes = queryNotesSync('/find ' + q);
      renderLiveResults(notes, q);
    } catch (e) {
      console.error(e);
      showFatal('Search/render error: ' + (e?.message || e));
    }
  };

  if (immediate) return doIt();

  clearTimeout(liveTimer);
  liveTimer = setTimeout(doIt, 120);
}

/* =========================
   LIVE SEARCH as you type
========================= */
userInput.addEventListener('input', () => {
  const q = userInput.value.trim();

  if (!q) {
    lastLiveQuery = '';
    if (isUnlocked) renderWelcome();
    else clearLiveResults();
    return;
  }

  runLiveSearch(q, false);
});

/* =========================
   Enter key behavior
========================= */
inputArea.addEventListener('submit', async (e) => {
  e.preventDefault();

  const raw = userInput.value.trim();
  if (!raw) return;

  if (/^\/ask\b/i.test(raw)) {
    const q = raw.replace(/^\/ask\s*/i, '').trim();
    if (!q) return;

    clearLiveResults();
    renderHeaderLine('Thinkingâ€¦');

    try {
      const answer = await askAI(q);
      clearLiveResults();
      renderHeaderLine(answer);
    } catch (err) {
      clearLiveResults();
      renderHeaderLine('âš ï¸ Error getting response');
      console.error(err);
    }
    return;
  }

  runLiveSearch(raw, true);
});

/* =========================
   Formatting toolbar
========================= */
document.getElementById('boldBtn').onclick = () => document.execCommand('bold');
document.getElementById('italicBtn').onclick = () => document.execCommand('italic');
document.getElementById('underlineBtn').onclick = () => document.execCommand('underline');
document.getElementById('highlightBtn').onclick = () => document.execCommand('foreColor', false, '#5c6ac4');
document.getElementById('redFontBtn').onclick = () => document.execCommand('foreColor', false, 'red');
document.getElementById('blueFontBtn').onclick = () => document.execCommand('foreColor', false, 'blue');

/* Font size controls */
function changeFontSize(delta) {
  const sel = window.getSelection();
  if (!sel.rangeCount || !activeEditable.contains(sel.anchorNode)) return;

  const range = sel.getRangeAt(0);

  if (!range.collapsed) {
    const selectedNodes = range.cloneContents().querySelectorAll('span.resizableEmoji');

    if (selectedNodes.length) {
      selectedNodes.forEach(span => {
        const currentSize = parseFloat(window.getComputedStyle(span).fontSize);
        const newSize = Math.max(8, currentSize + delta * 2);
        span.style.fontSize = newSize + 'px';
      });
      return;
    }

    const span = document.createElement('span');
    span.style.fontSize = delta > 0 ? 'larger' : 'smaller';
    span.appendChild(range.extractContents());
    range.insertNode(span);
  } else {
    const span = document.createElement('span');
    span.style.fontSize = delta > 0 ? 'larger' : 'smaller';
    span.appendChild(document.createTextNode('\u200B'));
    range.insertNode(span);
    range.setStart(span, 1);
    range.collapse(true);
    sel.removeAllRanges();
    sel.addRange(range);
  }

  saveCaret();
}

function resetFormatting() {
  const sel = window.getSelection();
  if (!sel.rangeCount || !activeEditable.contains(sel.anchorNode)) return;

  const range = sel.getRangeAt(0);
  if (range.collapsed) return;

  const extracted = range.extractContents();

  function unwrapNode(node) {
    if (node.nodeType === Node.TEXT_NODE) {
      return document.createTextNode(node.textContent);
    } else if (node.nodeType === Node.ELEMENT_NODE) {
      const frag = document.createDocumentFragment();
      node.childNodes.forEach(child => frag.appendChild(unwrapNode(child)));
      return frag;
    }
    return document.createTextNode('');
  }

  const cleanFragment = document.createDocumentFragment();
  extracted.childNodes.forEach(node => cleanFragment.appendChild(unwrapNode(node)));

  range.insertNode(cleanFragment);
  range.collapse(false);
  sel.removeAllRanges();
  sel.addRange(range);

  saveCaret();
}

document.getElementById('resetColorBtn').onclick = resetFormatting;
document.getElementById('increaseFontBtn').onclick = () => changeFontSize(1);
document.getElementById('decreaseFontBtn').onclick = () => changeFontSize(-1);

/* =========================
   Floating Emoji + Table tools
   (UNCHANGED from your version)
   - keep your existing code below exactly as you had it
========================= */

/* --- PASTE YOUR EXISTING FLOATING EMOJI + TABLE TOOLS + LOCK UI CODE HERE --- */

/* UI toggles */
lockToggle.onclick = () => {
  lockSection.style.display = (lockSection.style.display === 'flex') ? 'none' : 'flex';
};

unlockBtn.onclick = () => {
  const code = (accessCodeInput.value || '').trim();
  if (code === ACCESS_CODE) {
    setUnlocked(true);
    lockSection.style.display = 'none';
  } else {
    lockInfo.textContent = "Wrong code";
    accessCodeInput.select();
  }
};

lockBtn.onclick = () => {
  setUnlocked(false);
  lockSection.style.display = 'none';
};

document.getElementById('formatToggle').onclick = () =>
  document.getElementById('formatToolbar').classList.toggle('visible');

updateUIForLockState();
</script>

</body>
</html>
